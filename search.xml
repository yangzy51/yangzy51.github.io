<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/06/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>&#39;chenge-first-blog&#39;</title>
    <url>/2024/06/26/chenge-first-blog/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>InterProScan</title>
    <url>/2024/06/28/InterProScan/</url>
    <content><![CDATA[<h1 id="conda安装"><a href="#conda安装" class="headerlink" title="conda安装"></a>conda安装</h1><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c bioconda interproscan</span><br><span class="line"><span class="comment">#https://anaconda.org/bioconda/interproscan</span></span><br></pre></td></tr></table></figure>
<h2 id="下载、检查md5文件并解压数据库"><a href="#下载、检查md5文件并解压数据库" class="headerlink" title="下载、检查md5文件并解压数据库"></a>下载、检查md5文件并解压数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get the md5 of the databases</span></span><br><span class="line">wget https://ftp.ebi.ac.uk/pub/databases/interpro/iprscan/5/5.62-94.0/interproscan-5.62-94.0-64-bit.tar.gz.md5</span><br><span class="line"><span class="comment"># get the databases (with core because much faster to download)</span></span><br><span class="line">wget https://ftp.ebi.ac.uk/pub/databases/interpro/iprscan/5/5.62-94.0/interproscan-5.62-94.0-64-bit.tar.gz</span><br><span class="line"><span class="comment"># checksum</span></span><br><span class="line"><span class="built_in">md5sum</span> -c interproscan-5.62-94.0-64-bit.tar.gz.md5</span><br><span class="line"><span class="comment"># untar gz</span></span><br><span class="line">tar xvzf interproscan-5.62-94.0-64-bit.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="更改数据库"><a href="#更改数据库" class="headerlink" title="更改数据库"></a>更改数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># remove old DB 根据conda安装路径的数据库删除</span></span><br><span class="line"><span class="built_in">rm</span> -rf /home/yangzy/miniconda3/share/InterProScan/data/</span><br><span class="line"><span class="comment"># copy past the new db 把</span></span><br><span class="line">cp-r /home/yangzy/miniconda3/envs/interproscan/interproscan-5.62-94.0/data /home/yangzy/miniconda3/share/InterProScan/</span><br><span class="line"><span class="comment">#将wget到的数据库复制过去</span></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./interproscan.sh -i test_proteins.fasta -f tsv</span><br></pre></td></tr></table></figure>
<p>如果没有报错，则表示InterProScan能正常运行了<br>一般常用的参数有这些：<br>    -appl,–applications 用于指定使用Interpro中哪些数据库，默认全部数据库<br>    -b,–output-file-base 用于指定输出文件的路径or文件夹，默认是输入文件的路径<br>    -f,–formats 用于指定输出文件的后缀，蛋白序列默认输出TSV, XML and GFF3<br>    -i,–input 输入文件，一般要为fasta格式，不要带有其他特殊符号</p>
<h1 id="TBtools"><a href="#TBtools" class="headerlink" title="TBtools"></a>TBtools</h1><p>使用TBtools中的Batch Protein Annotation in InterPro插件<br>参考：<a href="https://mp.weixin.qq.com/s/4tIlpUekwHRlPe4yySFnFA">https://mp.weixin.qq.com/s/4tIlpUekwHRlPe4yySFnFA</a></p>
<p>上传1w条序列文件后，在分析到两千多条时显示超时错误：</p>
<p>咨询插件创作者得到反馈：<br>不建议一次1w 太多了 对interprot网站造成一定负担 可以少量多次 比如1000条分10次 另外一次量过多也容易产生ip被封的风险</p>
]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门基础课</title>
    <url>/2024/07/02/Python%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="Python基础语法学习"><a href="#Python基础语法学习" class="headerlink" title="Python基础语法学习"></a>Python基础语法学习</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>注释：</p>
<p>  使用 #表示注释行,一般井号在行首，也可以在行的中间，那么#后面的为注释信息</p>
<p>  带有 #号的行python解释器会忽略</p>
</li>
<li><p>缩进</p>
<p>  使用缩进表示层次关系，或者区分不同的代码块，不像perl语言用{} </p>
<p>  约定使用4个空格缩进</p>
</li>
<li><p>续行</p>
<p>  在行尾使用 \</p>
<p>  如果使用各种括号，认为括号内是一个整体，括号内部跨行不用 \</p>
</li>
</ul>
<p>Python示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">Description: This script is used to onvert U in fasta sequence file to T</span><br><span class="line">Date: 2019</span><br><span class="line">Auther: omicsgene</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio import SeqIO</span><br><span class="line">from Bio.Alphabet import IUPAC</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">import sys, os, argparse, os.path,re,math,time</span><br><span class="line">#参数设置</span><br><span class="line">parser = argparse.ArgumentParser(description=&#x27;This script is \</span><br><span class="line">    used to onvert U in fasta sequence file to T&#x27;)</span><br><span class="line">parser.add_argument(&#x27;-f&#x27;,&#x27;--fasta&#x27;,help=&#x27;Please fasta file&#x27;,required=True)</span><br><span class="line">parser.add_argument(&#x27;-o&#x27;,&#x27;--out_dir&#x27;,help=&#x27;Please input complete out_put directory path&#x27;,</span><br><span class="line">                    default = os.getcwd(),</span><br><span class="line">                    required=False)</span><br><span class="line"></span><br><span class="line">parser.add_argument(&#x27;-n&#x27;,&#x27;--name&#x27;,default =&#x27;demo_seq&#x27;,required=False,</span><br><span class="line">                    help=&#x27;Please specify the output, demo_seq&#x27;)</span><br><span class="line">################################################################################</span><br><span class="line">#读入参数，初始化路径</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">dout=&#x27;&#x27;</span><br><span class="line">if os.path.exists(args.out_dir):</span><br><span class="line">    dout=os.path.abspath(args.out_dir)</span><br><span class="line">else:</span><br><span class="line">    os.mkdir(args.out_dir)</span><br><span class="line">    dout=os.path.abspath(args.out_dir)</span><br><span class="line"></span><br><span class="line">output_handle = open(dout+&#x27;/&#x27;+args.name+&#x27;.fa&#x27;, &quot;w&quot;)</span><br><span class="line">#循环处理序列将U转换成T,然后输出</span><br><span class="line">for rec in SeqIO.parse(args.fasta, &quot;fasta&quot;):</span><br><span class="line">    seq=rec.seq</span><br><span class="line">    seq=str(seq.upper())</span><br><span class="line">    seq=seq.replace(&quot;U&quot;, &quot;T&quot;)</span><br><span class="line">    seq_r = SeqRecord(Seq(seq,alphabet = IUPAC.IUPACAmbiguousDNA()), </span><br><span class="line">                      id=rec.id,</span><br><span class="line">                      description=rec.description)</span><br><span class="line">    SeqIO.write(seq_r, output_handle, &quot;fasta&quot;)</span><br><span class="line">output_handle.close()</span><br></pre></td></tr></table></figure>




<h2 id="Python-标准数据类型和变量"><a href="#Python-标准数据类型和变量" class="headerlink" title="Python 标准数据类型和变量"></a>Python 标准数据类型和变量</h2><h4 id="数字："><a href="#数字：" class="headerlink" title="数字："></a>数字：</h4><ul>
<li>整数 integer：  11，223，-23   </li>
<li>布尔值 bool ：True  False</li>
<li>浮点数 float： 1.2  、 1.46 、  1.44e10 、 -1.6e-66</li>
<li>复数： 1+2j</li>
</ul>
<h4 id="字符串-string："><a href="#字符串-string：" class="headerlink" title="字符串 string："></a>字符串 string：</h4><ul>
<li>使用 ‘  “ 单引号或者双引号引用的字符</li>
<li>‘’’ 和 “”” 可以跨行，可以在其中任意的使用单双引号</li>
</ul>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">None</span><br></pre></td></tr></table></figure>


<p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p>
<h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><p>变量：</p>
<p>和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量名：</p>
<ol>
<li>必须是大小写英文字母、数字和 _ 的组合，且不能用数字开头。例如，可将变量命名为message_1，但不能将其命名为1_message。</li>
<li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。</li>
<li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print。</li>
<li>变量名应既简短又具有描述性，让人一看就知道里面代表的是什么数据。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。</li>
<li>慎用小写字母l和大写字母O，因给他们可能被人错看成数字1和0；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 123 # a是整数</span><br><span class="line">print(a)</span><br><span class="line">a = &#x27;ABC&#x27; # a变为字符串</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<h4 id="变量的理解"><a href="#变量的理解" class="headerlink" title="变量的理解"></a>变量的理解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &#x27;abc&#x27;</span><br><span class="line">b = a</span><br><span class="line">a = &#x27;xyz&#x27;</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<p>1： 执行a &#x3D; ‘abc’，解释器创建了字符串’abc’和变量a，并把a指向’abc’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a--&gt;abc</span><br></pre></td></tr></table></figure>
<p>2：执行b &#x3D; a，解释器创建了变量b，并把b指向a指向的字符串’abc’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a--&gt;abc</span><br><span class="line">b--&gt;abc</span><br></pre></td></tr></table></figure>

<p>3：执行a &#x3D; ‘xyz’，解释器创建了字符串’xyz’，并把a的指向改为’xyz’，但b并没有更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a--&gt;xyz</span><br><span class="line">b--&gt;abc</span><br></pre></td></tr></table></figure>


<h2 id="Python-标准数据的操作"><a href="#Python-标准数据的操作" class="headerlink" title="Python 标准数据的操作"></a>Python 标准数据的操作</h2><h4 id="数字操作运算"><a href="#数字操作运算" class="headerlink" title="数字操作运算"></a>数字操作运算</h4><ul>
<li>加减乘除  +  - *  &#x2F;</li>
<li>求余运算 %    求幂运算  **</li>
<li>自然除&#x2F; 结果是浮点数，整除&#x2F;&#x2F;。注意：在2.x中&#x2F;和&#x2F;&#x2F;都是整除。</li>
</ul>
<p>注意：字符串可以相加和相乘</p>
<h4 id="字符串中特殊字符的转义："><a href="#字符串中特殊字符的转义：" class="headerlink" title="字符串中特殊字符的转义：\"></a>字符串中特殊字符的转义：\</h4><ul>
<li>例如要在字符串中输入一个换行符： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;hello python\n&quot;</span><br></pre></td></tr></table></figure></li>
<li>其他常见特殊意义的转义：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\  \t  \r  \n  \&#x27;  \&quot;</span><br></pre></td></tr></table></figure></li>
<li>字符前缀 r</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(r&#x27;my name is \n \&quot;lucy\&quot;&#x27;)</span><br></pre></td></tr></table></figure>



<p>练习：<br>打印以下变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 122223</span><br><span class="line">y = 45116e-789</span><br><span class="line">a1 = &#x27;Hello, world&#x27;</span><br><span class="line">a2 = &#x27;Hello, \&#x27;Lily\&#x27;&#x27;</span><br><span class="line">a3 = r&#x27;Hello, &quot;Mike&quot;&#x27;</span><br><span class="line">a4 = r&#x27;&#x27;&#x27;Hello,</span><br><span class="line">omicsclass!&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="字符串格式化输出"><a href="#字符串格式化输出" class="headerlink" title="字符串格式化输出"></a>字符串格式化输出</h4><ul>
<li>%运算符格式化字符串</li>
<li>%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;Age: %s. Gender: %s&#x27; % (25, True))</span><br><span class="line">print(&#x27;growth rate: %d %%&#x27; % 7)</span><br><span class="line">print(&#x27;%2d-%02d&#x27; % (3, 1))</span><br><span class="line">print(&#x27;%.2f&#x27; % 3.1415926)</span><br></pre></td></tr></table></figure>



<h4 id="关于字符串操作的一些方法"><a href="#关于字符串操作的一些方法" class="headerlink" title="关于字符串操作的一些方法"></a>关于字符串操作的一些方法</h4><p>&#x3D;&#x3D;重点掌握：split，strip，join&#x3D;&#x3D;</p>
<p>方法的调用用 . 操作符</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>strip、rstrip、lstrip</td>
<td>去除空白符。相当于对各个元素执行x.strip()</td>
</tr>
<tr>
<td>split</td>
<td>通过指定的分隔符将字符串拆分为一组子串</td>
</tr>
<tr>
<td>join</td>
<td>将字符串用作连接其他字符串序列的分隔符</td>
</tr>
<tr>
<td>count</td>
<td>返回子串在字符串中出现次数</td>
</tr>
<tr>
<td>endswith、startswith</td>
<td>如果字符串以某个后缀结尾（或开头），则返回True</td>
</tr>
<tr>
<td>lower、upper</td>
<td>分别将字母字符转换为小写或大写</td>
</tr>
<tr>
<td>replace</td>
<td>用另一个字符串替换指定子串</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>ljust、rjust</td>
<td>用空格(或其他字符)填充字符串的空白侧以返回符合最低宽度的字符串</td>
</tr>
<tr>
<td>index</td>
<td>如果在字符串中找到子串，则返回子串第一个字符所在的位置。如果没有找到，则引发ValueError</td>
</tr>
<tr>
<td>find</td>
<td>如果在字符串中找到子串，则返回第一个发现的子串第一个字符所在的位置。如果没有找到，则返回-1</td>
</tr>
<tr>
<td>rfind</td>
<td>如果在字符串中找到子串，则返回最后一个发现的子串的第一个字符所在的位置。如果没有找到，则返回-1</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s = &#x27;A,T,C,G,A\n&#x27;</span><br><span class="line">print(s)</span><br><span class="line">print(s,end=&quot;&quot;)</span><br><span class="line">print(s.strip())</span><br><span class="line"></span><br><span class="line">s = &#x27;A,T,C,G,A&#x27;</span><br><span class="line">s.split(&#x27;,&#x27;)</span><br><span class="line"></span><br><span class="line">&quot;\t&quot;.join([&quot;A&quot;,&quot;T&quot;,&quot;T&quot;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = &#x27;A,T,C,G,A&#x27;</span><br><span class="line">s.replace(&#x27;A&#x27;,&#x27;T&#x27;)</span><br><span class="line">s.count(&#x27;,&#x27;)</span><br><span class="line">s.index(&#x27;c&#x27;)</span><br><span class="line">s.find(&#x27;c&#x27;)</span><br><span class="line">s.endwith(&quot;A&quot;)</span><br><span class="line">s.lower()</span><br><span class="line"></span><br><span class="line">#函数</span><br><span class="line">len(s)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 调用函数或者方法，一定要跟()</p>
<p>&#x3D;&#x3D;<strong>小知识</strong>&#x3D;&#x3D;<br>Python中函数和方法的区别：</p>
<p>在Python中，<strong>函数</strong>(function) 和<strong>方法</strong>(method) 是有区别的：</p>
<ul>
<li><p>所处的位置不同：函数是直接写在文件中而不是class中，方法是只能写在class中。</p>
</li>
<li><p>调用的方式不同：函数可以直接调用，例如：len()   print()等等，方法是在类中，一般用. 来调用，如： 前面学习的：lst.index()</p>
</li>
</ul>
<h2 id="python中的列表list和元组tuple"><a href="#python中的列表list和元组tuple" class="headerlink" title="python中的列表list和元组tuple"></a>python中的列表list和元组tuple</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>list 列表</strong></p>
<ul>
<li>list是一种有序的集合，可以随时添加和删除其中的元素。</li>
<li>元素的类型可以是任意对象(数字，字符串，逻辑值，列表，对象等等)</li>
<li>使用[]表示列表</li>
</ul>
<p><strong>tuple 元组</strong></p>
<ul>
<li>tuple：另一种有序列表,tuple和list非常类似，但是tuple一旦初始化就不能修改。</li>
<li>使用()表示元组</li>
</ul>
<p>list的创建与初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mylst=[]</span><br><span class="line">mylst=[1,3,&quot;a&quot;,&quot;xy&quot;,[11,22]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tuple的创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)</span><br><span class="line">t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])</span><br></pre></td></tr></table></figure>



<h3 id="列表list相关的操作-函数-方法"><a href="#列表list相关的操作-函数-方法" class="headerlink" title="列表list相关的操作&amp;函数&amp;方法"></a>列表list相关的操作&amp;函数&amp;方法</h3><h3 id="列表的查询："><a href="#列表的查询：" class="headerlink" title="列表的查询："></a>列表的查询：</h3><h5 id="支持索引用中括号："><a href="#支持索引用中括号：" class="headerlink" title="支持索引用中括号：[]"></a>支持索引用中括号：[]</h5><ul>
<li>正索引：从左到右，从0开始</li>
<li>负索引：从右往左，从-1开始</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst=[&quot;A&quot;,&quot;T&quot;,&quot;A&quot;,&quot;a&quot;,22,[333,444]]</span><br><span class="line"></span><br><span class="line">lst[1]</span><br><span class="line">lst[0]</span><br><span class="line">lst[-1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst=[&quot;A&quot;,&quot;T&quot;,&quot;A&quot;,&quot;a&quot;,22,[333,444]]</span><br><span class="line">lst[0:3]</span><br><span class="line">#表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</span><br><span class="line">#如果第一个索引是0，还可以省略：</span><br><span class="line">lst[:3]</span><br><span class="line"></span><br><span class="line">lst[-2:-1]</span><br><span class="line">lst[-2:]</span><br></pre></td></tr></table></figure>
<h5 id="注意多维"><a href="#注意多维" class="headerlink" title="注意多维[][]"></a>注意多维[][]</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst=[&quot;A&quot;,&quot;T&quot;,&quot;A&quot;,&quot;a&quot;,22,[333,444]]</span><br><span class="line">lst[5][0]</span><br></pre></td></tr></table></figure>

<h3 id="列表元素修改"><a href="#列表元素修改" class="headerlink" title="列表元素修改"></a>列表元素修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst=[&quot;A&quot;,&quot;T&quot;,&quot;A&quot;,&quot;a&quot;,22,[333,444]]</span><br><span class="line">lst[5][0]=333</span><br><span class="line"></span><br><span class="line">lst[0]=&quot;omicsclass&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="列表相关方法"><a href="#列表相关方法" class="headerlink" title="列表相关方法:"></a>列表相关方法:</h3><p>重点掌握方法：&#x3D;&#x3D;append  extend  sort&#x3D;&#x3D; </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>list.append(x)</td>
<td>在列表末尾添加新的对象</td>
</tr>
<tr>
<td>list.sort(key&#x3D;None, reverse&#x3D;False)</td>
<td>对原列表进行排序</td>
</tr>
<tr>
<td>list.extend(iterable)</td>
<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td>list.count(x)</td>
<td>统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td>list.index(x[, start[, end]])</td>
<td>从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td>list.insert(i, x)</td>
<td>将对象插入列表</td>
</tr>
<tr>
<td>list.pop([i])</td>
<td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td>list.remove(x)</td>
<td>移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td>list.reverse()</td>
<td>反向列表中元素</td>
</tr>
</tbody></table>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst=[&quot;A&quot;,&quot;T&quot;,&quot;A&quot;,&quot;a&quot;,22,[333,444]]</span><br><span class="line">#列表结尾追加元素</span><br><span class="line">lst.append(&quot;omicsgene&quot;) </span><br><span class="line"></span><br><span class="line">#将可迭代的对象元素追加进来；</span><br><span class="line">lst.extend([&quot;omicsgene&quot;,&quot;omicsclass&quot;]) </span><br><span class="line"></span><br><span class="line">#在指定的索引处插入元素</span><br><span class="line">lst.insert(1,&quot;omicsclass&quot;) </span><br><span class="line"></span><br><span class="line">#从左到右查询第一个匹配的元素删除</span><br><span class="line">lst.remove(&quot;A&quot;)  </span><br><span class="line"></span><br><span class="line">#不指定索引，就从列表结尾删除元素，并返回该元素</span><br><span class="line">#也可以指定索引弹出；</span><br><span class="line">lst.pop()</span><br><span class="line">lst.pop(2)</span><br><span class="line"></span><br><span class="line">#反转list，会修改原列表</span><br><span class="line"></span><br><span class="line">lst.reverse()</span><br></pre></td></tr></table></figure>

<h3 id="列表相关的函数"><a href="#列表相关的函数" class="headerlink" title="列表相关的函数"></a>列表相关的函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>len(list)</td>
<td>列表元素个数</td>
</tr>
<tr>
<td>list(iterable)</td>
<td>将可迭代对象转换为列表</td>
</tr>
<tr>
<td>max(list)</td>
<td>返回列表元素最大值</td>
</tr>
<tr>
<td>min(list)</td>
<td>返回列表元素最小值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=[11,44,5,55,33,31,62,42]</span><br><span class="line">len(a)</span><br><span class="line">max(a)</span><br><span class="line">min(b)</span><br><span class="line"></span><br><span class="line">list([11,44,5,55,33,31,62,42])</span><br><span class="line">list(range(10))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="列表的排序"><a href="#列表的排序" class="headerlink" title="列表的排序"></a>列表的排序</h3><p>有全局函数sorted，和列表自带方法sort</p>
<p><strong>list.sort(key&#x3D;None, reverse&#x3D;False)</strong></p>
<ul>
<li>key 指定带有一个参数的函数或者方法，用于从每个列表元素中提取比较键(例如key&#x3D;str.lower)。对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。默认值None表示直接对列表项排序而不计算一个单独的键值。</li>
<li>reverse – 排序规则，reverse &#x3D; True 降序 ， reverse &#x3D; False 升序（默认）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 1、最简单的排序</span><br><span class="line">l = [5,2,3,1,4 ]</span><br><span class="line">l.sort()</span><br><span class="line">print(l)   </span><br><span class="line"></span><br><span class="line">#反序</span><br><span class="line">l.sort(reverse=True)</span><br><span class="line">print(l)    </span><br><span class="line"></span><br><span class="line">##2、字符串排序</span><br><span class="line">StrList = [&#x27;Fast&#x27;, &#x27;Smooth&#x27;, &#x27;fast&#x27;, &#x27;isb&#x27;, &#x27;isa&#x27;, &#x27;smooth&#x27;]</span><br><span class="line">#一般字典序排列，但是大写在前，小写在后！！</span><br><span class="line">StrList.sort()</span><br><span class="line">print(StrList) </span><br><span class="line"></span><br><span class="line">##2.2忽略大小写，按abcd顺序</span><br><span class="line">StrList.sort(key=str.lower)</span><br><span class="line">print(StrList) </span><br><span class="line"></span><br><span class="line">##2.3按照字符串长度排序</span><br><span class="line">StrList.sort(key=len)</span><br><span class="line">print(StrList)</span><br><span class="line"></span><br><span class="line">#一起使用两个参数</span><br><span class="line">StrList.sort(key=len, reverse=True)</span><br><span class="line">print(StrList) </span><br></pre></td></tr></table></figure>


<p><strong>sorted(iterable, key&#x3D;None, reverse&#x3D;False)</strong></p>
<ul>
<li>iterable – 可迭代对象。 例如：列表  range对象  字符串等</li>
<li>key – 指定带有单个参数的函数，用于从 iterable 的每个元素中提取用于比较的键 (例如 key&#x3D;str.lower)。 默认值为 None (直接比较元素)。</li>
<li>reverse – 排序规则，reverse &#x3D; True 降序 ， reverse &#x3D; False 升序（默认）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [5,7,6,3,4,1,2]</span><br><span class="line">b = sorted(a)       # 保留原列表</span><br><span class="line">print(b)</span><br><span class="line">b = sorted(a,reverse=True)  </span><br><span class="line">print(b)</span><br><span class="line">a = [&#x27;Fast&#x27;, &#x27;Smooth&#x27;, &#x27;fast&#x27;, &#x27;isb&#x27;, &#x27;isa&#x27;, &#x27;smooth&#x27;]</span><br><span class="line">b = sorted(a,key=str.lower,reverse=False)  </span><br><span class="line">print(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>sort 与 sorted 区别：</strong></p>
<ul>
<li><p>调用方式不同：<br>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p>
</li>
<li><p>返回对象不同：<br>list 的 sort 方法是在原来的列表上操作，无返回值（None），而函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
</li>
</ul>
<h2 id="python中的字典dict和集合set"><a href="#python中的字典dict和集合set" class="headerlink" title="python中的字典dict和集合set"></a>python中的字典dict和集合set</h2><ul>
<li>dict  字典</li>
</ul>
<p>dict全称dictionary，使用键-值（key-value）存储，具有极快的查找速度。类似perl里面的hash。</p>
<h3 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h3><p>字典的每个键值 key&#x3D;&gt;value对 用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;b&#x27;: &#x27;3&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典的特性："><a href="#字典的特性：" class="headerlink" title="字典的特性："></a>字典的特性：</h3><ol>
<li>键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行(列表是可变类型)：</li>
<li>值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7, &#x27;Name&#x27;: &#x27;Manni&#x27;&#125; </span><br><span class="line"></span><br><span class="line">#会报错</span><br><span class="line">d = &#123;[&#x27;Name&#x27;]: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><p>向字典中 添加新内容的方法是增加新的键&#x2F;值对，修改或删除已有键&#x2F;值对:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line">d[&#x27;Name&#x27;]                        #取值</span><br><span class="line">d[&#x27;Age&#x27;] = 18                    # 更新</span><br><span class="line">d[&#x27;School&#x27;] = &quot;omicsclass&quot;       # 添加</span><br><span class="line"> </span><br><span class="line">#取值打印</span><br><span class="line">print( &quot;d[&#x27;Age&#x27;]: &quot;, d[&#x27;Age&#x27;])</span><br><span class="line">print(&quot;d[&#x27;School&#x27;]: &quot;, d[&#x27;School&#x27;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除字典元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">del d[&#x27;Name&#x27;]  # 删除键是&#x27;Name&#x27;的条目</span><br><span class="line">d.clear()      # 清空字典所有条目</span><br><span class="line">del d          # 删除字典</span><br><span class="line"> </span><br><span class="line">print(&quot;d[&#x27;Age&#x27;]: &quot;, d[&#x27;Age&#x27;])</span><br><span class="line">print(&quot;d[&#x27;School&#x27;]: &quot;, d[&#x27;School&#x27;])</span><br></pre></td></tr></table></figure>

<h3 id="字典内置方法"><a href="#字典内置方法" class="headerlink" title="字典内置方法"></a>字典内置方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>dict.keys()</td>
<td>以列表返回一个字典所有的键</td>
</tr>
<tr>
<td>dict.values()</td>
<td>以列表返回字典中的所有值</td>
</tr>
<tr>
<td>dict.items()</td>
<td>以列表返回可遍历的(键, 值) 元组数组</td>
</tr>
<tr>
<td>dict.get(key, default&#x3D;None)</td>
<td>返回指定键的值，如果值不在字典中返回default值</td>
</tr>
</tbody></table>
<p>判断字典key是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#使用格式：</span><br><span class="line">#key in dict</span><br><span class="line">#key not in dict</span><br><span class="line"></span><br><span class="line">d = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line">&#x27;Name&#x27; in d</span><br><span class="line">&#x27;Name&#x27; not in d</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>set  集合</li>
</ul>
<p>set 集合是一个无序的不重复元素序列。是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<ul>
<li>集合创建</li>
</ul>
<p>可以使用大括号 { } 或者 set() 函数创建集合。</p>
<p>注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<h4 id="集合的创建与运算"><a href="#集合的创建与运算" class="headerlink" title="集合的创建与运算"></a>集合的创建与运算</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">genes = &#123;&#x27;gene1&#x27;, &#x27;gene1&#x27;, &#x27;gene2&#x27;, &#x27;gene3&#x27;, &#x27;gene4&#x27;, &#x27;gene5&#x27;&#125;</span><br><span class="line"></span><br><span class="line">genes = set([&#x27;gene1&#x27;, &#x27;gene1&#x27;, &#x27;gene2&#x27;, &#x27;gene3&#x27;, &#x27;gene4&#x27;, &#x27;gene5&#x27;])</span><br><span class="line"></span><br><span class="line">print(genes)   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#集合运算与判断</span><br><span class="line">&#x27;gene1&#x27; in genes </span><br><span class="line"></span><br><span class="line">&#x27;gene11&#x27; in genes</span><br><span class="line"></span><br><span class="line">#字符有列表特性，所以可以直接set   </span><br><span class="line">a = set(&#x27;omicsgene&#x27;)</span><br><span class="line">b = set(&#x27;omicsclass&#x27;)</span><br><span class="line"></span><br><span class="line"># 集合a中包含而集合b中不包含的元素</span><br><span class="line">a - b                              </span><br><span class="line"># 集合a或b中包含的所有元素</span><br><span class="line">a | b                              </span><br><span class="line"># 集合a和b中都包含了的元素</span><br><span class="line">a &amp; b                              </span><br><span class="line"># 不同时包含于a和b的元素</span><br><span class="line">a ^ b                              </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="集合常用操作方法"><a href="#集合常用操作方法" class="headerlink" title="集合常用操作方法"></a>集合常用操作方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>set.add(x)</td>
<td>参数作为一个元素添加到原set集合</td>
</tr>
<tr>
<td>set.update(s)</td>
<td>可以添加多个元素，且参数可以是列表，元组，字典等</td>
</tr>
<tr>
<td>set.remove(x)</td>
<td>依据值删除，不存在会抛出异常KeyError</td>
</tr>
<tr>
<td>set.discard(x)</td>
<td>依据值删除，不存在不会报错</td>
</tr>
<tr>
<td>set.clear()</td>
<td>清空原set</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;</span><br><span class="line">basket.add((&quot;aa&quot;,&quot;dd&quot;))</span><br><span class="line">basket.update(&quot;dcc&quot;)</span><br><span class="line">print(basket)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">basket.remove(&quot;apple&quot;)</span><br><span class="line">basket.remove(&quot;apple1&quot;)</span><br><span class="line">basket.discard(&quot;apple1&quot;)</span><br><span class="line"></span><br><span class="line">basket.clear()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="数据类型及类型转换"><a href="#数据类型及类型转换" class="headerlink" title="数据类型及类型转换"></a>数据类型及类型转换</h2><p>Python3 支持 的标准数据类型总结</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>类名</th>
</tr>
</thead>
<tbody><tr>
<td>Number（数字）</td>
<td>int、float、bool、complex（复数）</td>
</tr>
<tr>
<td>String（字符串）</td>
<td>str</td>
</tr>
<tr>
<td>List（列表）</td>
<td>list</td>
</tr>
<tr>
<td>Tuple（元组）</td>
<td>tuple</td>
</tr>
<tr>
<td>Set（集合）</td>
<td>set</td>
</tr>
<tr>
<td>Dictionary（字典）</td>
<td>dict</td>
</tr>
</tbody></table>
<p>Python3 的六个标准数据类型中：</p>
<ul>
<li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li>
<li>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#批量赋值</span><br><span class="line">a, b, c, d ,e= 20, 5.5, &quot;ATGC&quot;, True, 4+3j</span><br><span class="line"></span><br><span class="line">#获得数据类型</span><br><span class="line">print(type(a), type(b), type(c), type(d), type(e))</span><br><span class="line"></span><br><span class="line">#判断数据类型</span><br><span class="line">a=1</span><br><span class="line">isinstance(a, int)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>类型转换函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int(x [,base])</td>
<td>将x转换为一个整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换到一个浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>list(s)</td>
<td>将序列 s 转换为一个列表</td>
</tr>
<tr>
<td>set(s)</td>
<td>转换为可变集合</td>
</tr>
<tr>
<td>tuple(s)</td>
<td>将序列 s 转换为一个元组</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>dict(d)</td>
<td>创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td>complex(real [,imag])</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str)</td>
<td>用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td>frozenset(s)</td>
<td>转换为不可变集合</td>
</tr>
<tr>
<td>chr(x)</td>
<td>将一个整数转换为一个字符</td>
</tr>
<tr>
<td>ord(x)</td>
<td>将一个字符转换为它的整数值</td>
</tr>
<tr>
<td>hex(x)</td>
<td>将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td>oct(x)</td>
<td>将一个整数转换为一个八进制字符串</td>
</tr>
</tbody></table>
<h2 id="python中语句-if、for、while"><a href="#python中语句-if、for、while" class="headerlink" title="python中语句(if、for、while)"></a>python中语句(if、for、while)</h2><h3 id="if-语句-做判断"><a href="#if-语句-做判断" class="headerlink" title="if 语句 做判断"></a>if 语句 做判断</h3><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<h4 id="python中常见比较判断运算符"><a href="#python中常见比较判断运算符" class="headerlink" title="python中常见比较判断运算符"></a>python中常见比较判断运算符</h4><p>&#x3D;&#x3D;、  !&#x3D; 、 &lt;  、&gt; 、 &gt;&#x3D; 、 &lt;&#x3D;、in、not in</p>
<p>注意：in、not in ： 判断值是否存在列表中或者字典的键中</p>
<h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#简单的判断</span><br><span class="line">age = 20</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&#x27;your age is&#x27;, age)</span><br><span class="line">    print(&#x27;adult&#x27;)</span><br><span class="line"></span><br><span class="line">l=[&#x27;Fast&#x27;, &#x27;Smooth&#x27;, &#x27;fast&#x27;, &#x27;isb&#x27;, &#x27;isa&#x27;, &#x27;smooth&#x27;]</span><br><span class="line">s = &#123;&#x27;gene1&#x27;, &#x27;gene1&#x27;, &#x27;gene2&#x27;, &#x27;gene3&#x27;, &#x27;gene4&#x27;, &#x27;gene5&#x27;&#125;</span><br><span class="line">d = &#123;&#x27;gene1&#x27;:122, &#x27;gene2&#x27;:2212, &#x27;gene3&#x27;:3121, &#x27;gene4&#x27;:2323, &#x27;gene5&#x27;:2543&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if &#x27;Fast&#x27; not in l:</span><br><span class="line">    print(True)</span><br><span class="line"></span><br><span class="line">#else 语句</span><br><span class="line">    </span><br><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&#x27;your age is&#x27;, age)</span><br><span class="line">    print(&#x27;adult&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;your age is&#x27;, age)</span><br><span class="line">    print(&#x27;teenager&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#elif语句    </span><br><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&#x27;adult&#x27;)</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print(&#x27;teenager&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;kid&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#判断条件依次执行，有一个为真就跳出</span><br><span class="line">age = 66</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&#x27;adult&#x27;)</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print(&#x27;teenager&#x27;)</span><br><span class="line">elif age &gt;= 60:</span><br><span class="line">    print(&#x27;old people&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;kid&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算符-增加判断条件"><a href="#逻辑运算符-增加判断条件" class="headerlink" title="逻辑运算符  增加判断条件"></a>逻辑运算符  增加判断条件</h4><ul>
<li>与 、或 、非 ：  and 、 or 、 not</li>
</ul>
<ol>
<li>and 如果第一个表达式为False，后面没有必要计算</li>
<li>or 如果第一个表达式是True，后面就没有必要计算了</li>
<li>条件很多不知道判断优先顺序可以添加小括号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#逻辑运算符</span><br><span class="line">age=11</span><br><span class="line">gender=&quot;male&quot;</span><br><span class="line"></span><br><span class="line">if age&gt;=18 and age&lt;=60 and gender==&quot;female&quot;:</span><br><span class="line">    print(&quot;adult woman&quot;)</span><br><span class="line"></span><br><span class="line">if age&lt;18 or age &gt;60 and gender==&quot;female&quot;:</span><br><span class="line">    print(&quot;kid or old woman&quot;)  </span><br><span class="line">    </span><br><span class="line">if age&gt;=18 and age&lt;=60 and not gender==&quot;female&quot;:</span><br><span class="line">    print(&quot;adult man&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="特殊数据真值表"><a href="#特殊数据真值表" class="headerlink" title="特殊数据真值表"></a>特殊数据真值表</h4><table>
<thead>
<tr>
<th>对象&#x2F;变量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>“”</td>
<td>假</td>
</tr>
<tr>
<td>“string”</td>
<td>真</td>
</tr>
<tr>
<td>0</td>
<td>假</td>
</tr>
<tr>
<td>() 空元组</td>
<td>假</td>
</tr>
<tr>
<td>[] 空列表</td>
<td>假</td>
</tr>
<tr>
<td>{} 空字典</td>
<td>假</td>
</tr>
<tr>
<td>None</td>
<td>假</td>
</tr>
</tbody></table>
<h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><p>计算机之所以能批量的执行数据分析，就是因为有循环语句。</p>
<p>for…in循环，in 后面跟可迭代对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列表遍历</span><br><span class="line">names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">sum = 0</span><br><span class="line">for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#产生连续的数字函数：range(start, stop[, step])</span><br><span class="line"></span><br><span class="line">range(10)</span><br><span class="line">range(2,10)</span><br><span class="line">#也可以转换成list对象</span><br><span class="line">list(range(10))</span><br><span class="line">list(range(1, 11))</span><br><span class="line">list(range(0, 30, 5))</span><br><span class="line">list(range(0, 10, 3))</span><br><span class="line">list(range(0, -10, -1))</span><br><span class="line">list(range(0))</span><br><span class="line">list(range(1, 0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line">for x in range(101):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line">for x in range(3,101):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line">for x in range(3,101,2):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#enumerate函数  同时获取索引还有值</span><br><span class="line"></span><br><span class="line">#用法enumerate(sequence, [start=0])</span><br><span class="line"></span><br><span class="line">names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">for index,value in enumerate(names):</span><br><span class="line">    print(index,value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#字典遍历</span><br><span class="line">dict = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line">for k,v in dict.items():</span><br><span class="line">    print(k,v)</span><br><span class="line"></span><br><span class="line">dict = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line">for k in dict.keys():</span><br><span class="line">    print(k,dict[k])</span><br></pre></td></tr></table></figure>

<h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 2</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>break  提前退出循环<br>continue  提前结束本轮循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 1</span><br><span class="line">while n &lt;= 100:</span><br><span class="line">    if n &gt; 10: # 当n = 11时，条件满足，执行break语句</span><br><span class="line">        break # break语句会结束当前循环</span><br><span class="line">    print(n)</span><br><span class="line">    n = n + 1</span><br><span class="line">print(&#x27;END&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = 0</span><br><span class="line">while n &lt; 10:</span><br><span class="line">    n = n + 1</span><br><span class="line">    if n % 2 == 0: # 如果n是偶数，执行continue语句</span><br><span class="line">        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;练习题&#x3D;&#x3D;</p>
<ol>
<li>for 循环打印星号金字塔：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    *</span><br><span class="line">   ***</span><br><span class="line">  *****</span><br><span class="line"> *******</span><br><span class="line">*********</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(1, 6):</span><br><span class="line">     for j in range(0, 6 - i):</span><br><span class="line">         print (&quot; &quot;,end=&quot;&quot;)</span><br><span class="line">     </span><br><span class="line">     print( &quot;*&quot;*(i),end=&quot;&quot;)</span><br><span class="line">     print( &quot;*&quot;*(i-1),end=&quot;&quot;)       </span><br><span class="line">     print(&quot;&quot;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用for循环，打印乘法口诀：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1*1=1	</span><br><span class="line">1*2=2	2*2=4	</span><br><span class="line">1*3=3	2*3=6	3*3=9	</span><br><span class="line">1*4=4	2*4=8	3*4=12	4*4=16	</span><br><span class="line">1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	</span><br><span class="line">1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	</span><br><span class="line">1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	</span><br><span class="line">1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	</span><br><span class="line">1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81	</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for m in range(1, 10):</span><br><span class="line">    for n in range(1, m+1):</span><br><span class="line">        print(&quot;%d*%d=%d\t&quot;%(n,m,n*m), end=&quot;&quot;)</span><br><span class="line">    print(&quot;&quot;)</span><br></pre></td></tr></table></figure>


<h2 id="python-读写数据文件"><a href="#python-读写数据文件" class="headerlink" title="python 读写数据文件"></a>python 读写数据文件</h2><h3 id="python文件读写分为三步"><a href="#python文件读写分为三步" class="headerlink" title="python文件读写分为三步"></a>python文件读写分为三步</h3><ol>
<li>打开文件获取文件对象</li>
<li>操作文件</li>
<li>关闭文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fr = open(&quot;test.txt&quot;,&quot;r&quot;)      #打开文件</span><br><span class="line">ff = fr.read()                 #读取文件所有内容  （不建议使用，如果文件内容巨大，内存会爆）</span><br><span class="line">print(ff) </span><br></pre></td></tr></table></figure>

<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读，默认模式   打开数据文件</td>
</tr>
<tr>
<td>w</td>
<td>只写，不可读，若文件不存在则创建，若存在，则删除内容，写入新内容</td>
</tr>
<tr>
<td>a</td>
<td>只追加，不可读，若文件不存在则创建，存在则追加新内容</td>
</tr>
</tbody></table>
<h3 id="文件方法（不常用）"><a href="#文件方法（不常用）" class="headerlink" title="文件方法（不常用）"></a>文件方法（不常用）</h3><p> 前三个方法：在大文件时慎用，会把内容读到内存中，占用大内存</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>f.write()</td>
<td>字符串写入一个打开的文件</td>
</tr>
<tr>
<td>f.close()</td>
<td>刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>f.read()</td>
<td>#读取所有内容</td>
</tr>
<tr>
<td>f.readline()</td>
<td>#读取一行</td>
</tr>
<tr>
<td>f.readlines()</td>
<td>#读取所有文件内容，返回一个list</td>
</tr>
<tr>
<td>f.seek(0)</td>
<td>#当前文件指针位置在0位</td>
</tr>
<tr>
<td>f.writelines([“a”,”b”])</td>
<td>#把列表写入文件</td>
</tr>
</tbody></table>
<h4 id="文件的读入与写出（常用方法）："><a href="#文件的读入与写出（常用方法）：" class="headerlink" title="文件的读入与写出（常用方法）："></a>文件的读入与写出（常用方法）：</h4><p>文件的读入与写出主要用的是for循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fr=open(&quot;input.fa&quot;,&quot;r&quot;)   #输入文件，读取数据</span><br><span class="line">fw=open(&quot;output.fa&quot;,&quot;w&quot;)   #输出文件，写出结果</span><br><span class="line">for line in fr:              #循环一行一行的读取文件                                 </span><br><span class="line">    new_line = line.replace(&quot;A&quot;,&quot;T&quot;)                         </span><br><span class="line">    fw.write(new_line)</span><br><span class="line">fr.close()  #关闭文件</span><br><span class="line">fw.close()  #关闭文件</span><br></pre></td></tr></table></figure>


<p>测试文件内容：<br>input.fa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AGTTAGCGGATAATGGCCATCAAAGCAACGCTTACCAACACTGCACCCCTTGTTTTGGAAATGCAACCAC</span><br><span class="line">AAAAGCATTGGACACTTGCTTACTTCAAATAAAACACATTTAAACAATTAGATGACGTGATGGACCAGAA</span><br><span class="line">TGGCGCATCGGGAAGTCATCCGAACAGGCTATCCCAAGGAAGAGGAGCCCATGCGCGCGAACGTGGCGCC</span><br><span class="line">ACAGTTTCCGCGGCGGCAAATCGGAGTAACATTATCGACGAAATGGCCAAAATATGCGAAGCCGATCGCC</span><br><span class="line">AGACTTTCGCCATCGCTCGACGGACTCGGGGTCACGAGCGGCTTGCGGTGGACAACAGCGACTTCGTCGC</span><br><span class="line">CGTGGAGGATCTTATTTTGTCCTACGCAGAGCCCACGCCCGAGGACCAGGTCGAGATGATCATGAGCGAC</span><br><span class="line">TTTTGCTCGTCTCCAACATACGCAGAGGATGAGGATGAGCCCAGCCATGAGTCGGAGCCGTGGTTTCGAT</span><br><span class="line">TTCGCAACAAAAGGATCAGAACCTACAGCCGGAAGAGGGATCCCAAAAGCCACAAGGCCGTTCAAAACGA</span><br><span class="line">GAAGCGTAGAGGTTCCTCAGGCCTCTCCGTGCAGAGGGATCTCAATACTTCGTTCACATCTATGGCTTGT</span><br><span class="line">GATTTCGATGCTTCATCACAGAAGATACACGAGGTCCTTTTGAACCTCAGTCAATACTTTTCCGCGACCG</span><br><span class="line">CGACAGCTTCCGGTCCGACTCCTGTCCCATCGCAAATAGATCTGCCAACCGAAGCAAGGCAGGATT</span><br></pre></td></tr></table></figure>

<hr>
<p>&#x3D;&#x3D;学习任务&#x3D;&#x3D;</p>
<ul>
<li>编写脚本要求：</li>
<li><input checked="" disabled="" type="checkbox"> 读取gff文件，筛选出文件中1号染色体100000-500000之间的基因</li>
<li><input checked="" disabled="" type="checkbox"> 输出基因的名字，染色体，起始位置，终止位置信息用tab分隔各列</li>
</ul>
<p>输入文件下载地址：</p>
<p><a href="ftp://ftp.ensemblgenomes.org/pub/plants/release-44/gff3/arabidopsis_thaliana/Arabidopsis_thaliana.TAIR10.44.chromosome.1.gff3.gz">ftp://ftp.ensemblgenomes.org/pub/plants/release-44/gff3/arabidopsis_thaliana/Arabidopsis_thaliana.TAIR10.44.chromosome.1.gff3.gz</a></p>
<p>注意：几乎所有的生物数据文件都是文本文件，都可以用notepad++，editplus等文本编辑器打开，不要被文件后缀名迷惑，我们的编程语言python绝大多数情况下打开处理的也都是文本文件。</p>
<hr>
<p><strong>答案：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fr=open(&quot;D:\python_script\Arabidopsis_thaliana.TAIR10.44.chromosome.1.gff3\Arabidopsis_thaliana.TAIR10.44.chromosome.1.gff3&quot;,&quot;r&quot;)</span><br><span class="line">fw=open(&quot;D:\python_script\Arabidopsis_thaliana.TAIR10.44.chromosome.1.gff3\out.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">for line in fr:</span><br><span class="line">    line=line.strip()</span><br><span class="line">    if not line[0]==&quot;#&quot;:</span><br><span class="line">        tmp=line.split(&quot;\t&quot;)</span><br><span class="line">        if tmp[0]==&quot;1&quot; and tmp[2]==&quot;gene&quot; and int(tmp[3])&gt;100000 and int(tmp[3])&lt;500000:</span><br><span class="line">            geneID=tmp[8].split(&quot;;&quot;)[0].split(&quot;=&quot;)[1]</span><br><span class="line">            #mystr=tmp[0]+&quot;\t&quot;+tmp[3]+&quot;\t&quot;+tmp[4]+&quot;\t&quot;+geneID+&quot;\n&quot;</span><br><span class="line">            mystr=&quot;\t&quot;.join([tmp[0],tmp[3],tmp[4],geneID])+&quot;\n&quot;</span><br><span class="line">            fw.write(mystr)</span><br><span class="line">            #fw.write(line+&quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line">fr.close()</span><br><span class="line">fw.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Learn_Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 高级编程</title>
    <url>/2024/07/02/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Python高级编程"><a href="#Python高级编程" class="headerlink" title="Python高级编程"></a>Python高级编程</h1><h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1 函数"></a>1 函数</h2><h3 id="1-1-Python内置函数："><a href="#1-1-Python内置函数：" class="headerlink" title="1.1 Python内置函数："></a>1.1 Python内置函数：</h3><p>Python内置了很多有用的函数，我们可以直接调用。</p>
<p>内置函数总结：<a href="https://docs.python.org/zh-cn/3.7/library/functions.html">https://docs.Python.org/zh-cn/3.7/library/functions.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abs(-100)</span><br><span class="line">max(1, 2)</span><br><span class="line">int(&#x27;123&#x27;)</span><br><span class="line">float(&#x27;12.34&#x27;)</span><br><span class="line">sum([2,323,23])</span><br></pre></td></tr></table></figure>

<h3 id="1-2-Python-用户自定义函数"><a href="#1-2-Python-用户自定义函数" class="headerlink" title="1.2 Python 用户自定义函数"></a>1.2 Python 用户自定义函数</h3><p>自定义函数：把具有独立功能的代码块组织成为一个小模块。</p>
<p>好处：</p>
<ol>
<li>代码复用，提高编程效率，使程序易于理解。</li>
<li>自己学会定义函数，有助于理解看懂别人函数的帮助</li>
</ol>
<h4 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h4><p>你可以定义一个自定义功能的函数，以下是简单的规则：</p>
<ol>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。</li>
<li>括号里面可设置参数，参数不是必必需的(可有可无)，传入参数必须放在圆括号中间。</li>
<li>函数的第一行语句可以选择性地（可有可无）使用文档字符串—用于存放函数使用说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ol>
<p>参数作用：增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据</p>
<ol>
<li>在函数内部，把参数当作变量使用，进行需要的数据处理</li>
<li>函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#定义</span><br><span class="line">def hello(s):</span><br><span class="line">    &#x27;&#x27;&#x27;this function is used to say hello,</span><br><span class="line">    and exit.</span><br><span class="line">    </span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;hello &#x27;+s)</span><br><span class="line">    return</span><br><span class="line">    </span><br><span class="line">#调用</span><br><span class="line">hello(s=&quot;omicsgene&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="不同类型参数的设置与使用"><a href="#不同类型参数的设置与使用" class="headerlink" title="不同类型参数的设置与使用"></a>不同类型参数的设置与使用</h4><h5 id="参数根据位置传递"><a href="#参数根据位置传递" class="headerlink" title="参数根据位置传递"></a>参数根据位置传递</h5><p>如果我们设置了多个参数，python解释器会根据位置进行传递；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def power(x, n):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line">power(2,3)</span><br><span class="line"></span><br><span class="line">power(x=2,n=3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h5><p>直接设定参数，没有给参数的默认值，函数调用时必需给参数传入值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def power(x, n):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br><span class="line">    </span><br><span class="line">power(4)</span><br></pre></td></tr></table></figure>



<h5 id="设置默认参数-函数调用时可有可无"><a href="#设置默认参数-函数调用时可有可无" class="headerlink" title="设置默认参数(函数调用时可有可无)"></a>设置默认参数(函数调用时可有可无)</h5><p>设置参数是可以设定参数的默认值，函数调用时可选给参数传入值们不给就是默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line">def info(name, gender, age=6, city=&#x27;Beijing&#x27;):</span><br><span class="line">    print(&#x27;name:&#x27;, name)</span><br><span class="line">    print(&#x27;gender:&#x27;, gender)</span><br><span class="line">    print(&#x27;age:&#x27;, age)</span><br><span class="line">    print(&#x27;city:&#x27;, city)</span><br></pre></td></tr></table></figure>


<h5 id="可变参数位置参数"><a href="#可变参数位置参数" class="headerlink" title="可变参数位置参数"></a>可变参数位置参数</h5><p>* 在参数名字前面加一个星号，使参数成为一个可变参数，参数传入一个列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add(a,b):</span><br><span class="line">    return a+b</span><br><span class="line"></span><br><span class="line">def add1(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n </span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>

<h5 id="可变关键字参数"><a href="#可变关键字参数" class="headerlink" title="可变关键字参数"></a>可变关键字参数</h5><p>** 在参数名字前面加两个星号，使参数成为一个可变关键字参数，参数传入一个字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kwargs):</span><br><span class="line">    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#联合使用，参数如何传递？  </span><br><span class="line">def foo(a,b,c=22,*args,**kwargs):</span><br><span class="line">    print(&quot;a:&quot;,a,&quot;,&quot;,&quot;b:&quot;,b,&quot;,&quot;,&quot;c:&quot;,c,&quot;,&quot;,&quot;args:&quot;,args,&quot;,&quot;,&quot;kwargs:&quot;,kwargs)</span><br></pre></td></tr></table></figure>

<h5 id="强制-key-value形式传递"><a href="#强制-key-value形式传递" class="headerlink" title="强制  key&#x3D;value形式传递"></a>强制  key&#x3D;value形式传递</h5><p>有个参数只有一个星号,表示星号后面的参数必须用（key&#x3D;value）的形式进行传递参数，不能省略key。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo1(a,b,*,c=3):</span><br><span class="line">    print(a,b,c)</span><br><span class="line">    </span><br><span class="line">def foo2(a,b,c=3):</span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">foo1(1,2,4)</span><br><span class="line">foo2(1,2,4)</span><br></pre></td></tr></table></figure>


<h5 id="函数编写与调用注意事项"><a href="#函数编写与调用注意事项" class="headerlink" title="函数编写与调用注意事项"></a>函数编写与调用注意事项</h5><ol>
<li>必需参数一般写在前面，有默认值的参数紧随其后（位置参数）</li>
<li>参数名省略时，注意位置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo(a,b,c=22,*args,**kwargs):</span><br><span class="line">    print(a,b,c,args,kwargs)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>



<h3 id="1-3-Python中匿名函数"><a href="#1-3-Python中匿名函数" class="headerlink" title="1.3 Python中匿名函数"></a>1.3 Python中匿名函数</h3><p>有时候一个函数只是临时使用一下，以后就不会再使用了，要是用def定义比较麻烦。这个时候就可以用lambda来定义一个匿名函数</p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p>变量名&#x3D; lambda [arg1[, arg2, … argN]]: expression</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><ol>
<li>参数：可选，通常以逗号分隔的变量表达式形式，也就是位置参数</li>
<li>表达式中不能包含 循环，return</li>
<li>可以包含 if…else…语句.</li>
<li>表达式计算的结果直接返回</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用lambda的表达式</span><br><span class="line">lambda x, y: x + y</span><br><span class="line"></span><br><span class="line"># 使用def定义的函数</span><br><span class="line">def add( x, y ):</span><br><span class="line">  return x + y</span><br><span class="line"></span><br><span class="line"># lambda也允许有默认值和使用变长参数</span><br><span class="line">lambda x, y = 2: x + y</span><br><span class="line">lambda *z: z</span><br><span class="line"></span><br><span class="line"># 调用lambda函数</span><br><span class="line">a = lambda x, y: x + y</span><br><span class="line">a(1, 3)</span><br><span class="line"></span><br><span class="line">b = lambda x, y = 2: x + y</span><br><span class="line">b(1)</span><br><span class="line"></span><br><span class="line">b(1, 3)</span><br><span class="line"></span><br><span class="line">c = lambda *z: z</span><br><span class="line">c(10, &#x27;test&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="匿名函数应用"><a href="#匿名函数应用" class="headerlink" title="匿名函数应用"></a>匿名函数应用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#自定义排序关键字</span><br><span class="line"></span><br><span class="line">students = [(&#x27;john&#x27;, &#x27;A&#x27;, 15), (&#x27;jane&#x27;, &#x27;B&#x27;, 12), (&#x27;dave&#x27;, &#x27;B&#x27;, 10)]</span><br><span class="line">sorted(students, key=lambda s: s[2])            # 按年龄排序</span><br><span class="line">sorted(students, key=lambda s: s[2], reverse=True)       # 按降序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#字典排序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dic = &#123;&#x27;a&#x27;:2,&#x27;b&#x27;:1&#125;</span><br><span class="line">#按照key排序</span><br><span class="line">d = sorted(dic.items(), key = lambda k:k[0])</span><br><span class="line"></span><br><span class="line">#按照values排序</span><br><span class="line"> e = sorted(dic.items(), key = lambda k:k[1])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-4-变量作用域"><a href="#1-4-变量作用域" class="headerlink" title="1.4 变量作用域"></a>1.4 变量作用域</h3><p>变量的作用域决定了在哪一部分程序你可以访问那个特定的变量名称。一个程序的所有的变量并不是在任何位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。</p>
<p>两种最基本的变量作用域如下：</p>
<ul>
<li>全局变量</li>
<li>局部变量</li>
</ul>
<h5 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h5><ul>
<li><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
</li>
<li><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">total = 0; # 这是一个全局变量</span><br><span class="line"></span><br><span class="line">def mysum( arg1, arg2 ):</span><br><span class="line">   total = arg1 + arg2; # total在这里是局部变量.</span><br><span class="line">   print(&quot;inside  &quot;, total)</span><br><span class="line">   return total</span><br><span class="line"> </span><br><span class="line">#调用mysum函数</span><br><span class="line">mysum( 10, 20 )</span><br><span class="line">print(&quot;global var &quot;, total)</span><br></pre></td></tr></table></figure>


<h3 id="1-5-变量传递给参数参数的可变性"><a href="#1-5-变量传递给参数参数的可变性" class="headerlink" title="1.5 变量传递给参数参数的可变性"></a>1.5 变量传递给参数参数的可变性</h3><p>函数的参数传递中传入可变数据和不可变数据会有不同：</p>
<ul>
<li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li>
<li>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
<h5 id="传不可变对象实例-传进去的变量不改变原变量"><a href="#传不可变对象实例-传进去的变量不改变原变量" class="headerlink" title="传不可变对象实例,传进去的变量不改变原变量"></a>传不可变对象实例,传进去的变量不改变原变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def ChangeInt(a):</span><br><span class="line">    a = 10</span><br><span class="line"> </span><br><span class="line">b = 2</span><br><span class="line">ChangeInt(b)</span><br><span class="line">print (b) # 结果是 2</span><br></pre></td></tr></table></figure>

<h5 id="传可变对象实例-传进去的变量可改变原变量"><a href="#传可变对象实例-传进去的变量可改变原变量" class="headerlink" title="传可变对象实例,传进去的变量可改变原变量"></a>传可变对象实例,传进去的变量可改变原变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def changeme(mylist):</span><br><span class="line">   &quot;修改传入的列表&quot;</span><br><span class="line">   mylist.append([1,2,3,4]);</span><br><span class="line">   print(&quot;Inside value:&quot;, mylist)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line"># 调用changeme函数</span><br><span class="line">mynum = [10,20,30]</span><br><span class="line">changeme(mynum)</span><br><span class="line">print(&quot;Outside value:&quot;, mynum)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-面向对象的编程与获取帮助"><a href="#2-面向对象的编程与获取帮助" class="headerlink" title="2 面向对象的编程与获取帮助"></a>2 面向对象的编程与获取帮助</h2><h3 id="2-1-类和实例"><a href="#2-1-类和实例" class="headerlink" title="2.1 类和实例"></a>2.1 类和实例</h3><blockquote>
<p>面向对象最重要的概念就是类（Class）和实例（Instance），类描述了一组具有相同特性（属性）和相同行为（方法）的对象(Object)。面向对象的编程语言最大的特色就是可以编写自己所需的数据类型，以更好的解决问题。</p>
</blockquote>
<blockquote>
<p>必须牢记类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法或者属性，但各自的数据可能不同。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/group/92990402/noteresource/8DB0B3FB6790404EADCA0B71D9EB70F1/version/987?method=get-resource&shareToken=08DB9C16FB6D47AA8EBD104017423D2D&entryId=446741437" alt="image"></p>
<h4 id="面向对象编程特点"><a href="#面向对象编程特点" class="headerlink" title="面向对象编程特点"></a>面向对象编程特点</h4><p>面向对象编程(Object-oriented programming，缩写：OOP)的3个基本特征是：封装、继承、多态</p>
<ul>
<li><p>封装：将属性和方法(数据和功能)封装在一起形成类。 </p>
</li>
<li><p>继承：可以使用现有类的功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>
</li>
<li><p>多态：允许让父类的指针分别指向不同的子类, 调用不同子类的同一个方法, 会有不同的执行效果</p>
</li>
</ul>
<h3 id="2-2-面向对象编程"><a href="#2-2-面向对象编程" class="headerlink" title="2.2 面向对象编程"></a>2.2 面向对象编程</h3><h4 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h4><h5 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h5><ul>
<li>属性(对象的属性) ——变量：状态、静态的</li>
<li>方法(对象的行为) ——函数：过程、动态的</li>
</ul>
<h5 id="类的方法与属性"><a href="#类的方法与属性" class="headerlink" title="类的方法与属性"></a>类的方法与属性</h5><blockquote>
<p>在类的内部，使用 def 关键字来定义一个方法，类的方法与普通的函数只有一个特别的区别——他们的第一个参数必须是 self。</p>
</blockquote>
<blockquote>
<p>self代表类的实例，而非类。</p>
</blockquote>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>类有一个名为 __init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#类的定义</span><br><span class="line">class Car:</span><br><span class="line">    &#x27;&#x27;&#x27;this class define a car &#x27;&#x27;&#x27;</span><br><span class="line">    #类属性  共有属性</span><br><span class="line">    wheels=4</span><br><span class="line">    #构造方法</span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        #成员属性</span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.orometer_reading = 0</span><br><span class="line">    #类方法</span><br><span class="line">    def get_description(self):</span><br><span class="line">        long_name = str(self.year) + &#x27; &#x27; + self.make + &#x27; &#x27; + self.model+&quot; &quot;+str(self.wheels)</span><br><span class="line">        return long_name</span><br><span class="line"> </span><br><span class="line">    def get_odometer(self):</span><br><span class="line">        print(&quot;This car has &quot;+ str(self.orometer_reading) + &quot; miles on it&quot;)</span><br><span class="line"> </span><br><span class="line">    def increase(self,miles):</span><br><span class="line">        self.orometer_reading +=miles</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建类的实例化对象，访问属性和使用方法"><a href="#创建类的实例化对象，访问属性和使用方法" class="headerlink" title="创建类的实例化对象，访问属性和使用方法"></a>创建类的实例化对象，访问属性和使用方法</h4><p>现在让我们新建一个对象my_car:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#类实例my_car</span><br><span class="line">my_car = Car(&quot;yellow&quot;, &quot;beetle&quot;, 1967)</span><br><span class="line">#查看属性</span><br><span class="line">print(f&quot; My &#123;my_car.color&#125; car &#123;my_car.model&#125; is made in &#123;my_car.year&#125;&quot;)</span><br><span class="line"></span><br><span class="line">#属性修改</span><br><span class="line">my_car.color=&quot;black&quot;</span><br><span class="line"></span><br><span class="line">#对象方法调用</span><br><span class="line"></span><br><span class="line">my_car.get_description()</span><br><span class="line">my_car.increase(1000)</span><br><span class="line">my_car.read_odometer()</span><br><span class="line">my_car.update_orometer(20000)</span><br><span class="line"></span><br><span class="line">#查看类或者实例所有的属性与方法</span><br><span class="line">dir(my_car)</span><br><span class="line">dir(Car)</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Python-类定义中的特殊属性与方法"><a href="#2-3-Python-类定义中的特殊属性与方法" class="headerlink" title="2.3 Python 类定义中的特殊属性与方法"></a>2.3 Python 类定义中的特殊属性与方法</h3><p>Python中用下划线作为变量前缀和后缀指定特殊变量</p>
<ul>
<li>_xxx 不能用’from module import *’导入</li>
<li>__xxx 类中的私有变量名</li>
<li>__xxx__ 系统定义的名字</li>
<li>核心风格：避免用下划线作为变量名的开始。</li>
</ul>
<p>因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。</p>
<p>&#x3D;&#x3D;一般来讲，变量名_xxx被看作是“私有的”，在模块或类外不可以使用。&#x3D;&#x3D;</p>
<p>当变量是私有的时候，用_xxx 来表示变量是很好的习惯。因为变量名__xxx__对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。</p>
<ul>
<li>“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；</li>
<li>“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</li>
</ul>
<h5 id="Python类的特殊属性"><a href="#Python类的特殊属性" class="headerlink" title="Python类的特殊属性"></a>Python类的特殊属性</h5><table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>__class__</td>
<td>对象或类所属的类</td>
</tr>
<tr>
<td>__name__</td>
<td>类、函数、方法等的名字</td>
</tr>
<tr>
<td>__dict__</td>
<td>类的属性  以key-value形式展示的字典，展示出属性所对应的值</td>
</tr>
<tr>
<td>__module__</td>
<td>类定义所在的模块名称</td>
</tr>
<tr>
<td>__doc__</td>
<td>类、函数的文档字符串，如果没有定义则为None</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#print(my_car.__name__)</span><br><span class="line">print(my_car.__doc__)</span><br><span class="line">print(my_car.__dict__)</span><br><span class="line">print(my_car.__module__)</span><br><span class="line">print(my_car.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Car.__name__)</span><br><span class="line">print(Car.__doc__)</span><br><span class="line">print(Car.__dict__)</span><br><span class="line">print(Car.__module__)</span><br><span class="line">print(Car.__class__)</span><br></pre></td></tr></table></figure>



<h5 id="Python类特殊方法"><a href="#Python类特殊方法" class="headerlink" title="Python类特殊方法"></a>Python类特殊方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>__new__()</td>
<td>类的静态方法，用于确定是否创建对象</td>
</tr>
<tr>
<td>__init__()</td>
<td>构造函数，生成对象时调用</td>
</tr>
<tr>
<td>__dir__</td>
<td>返回类或者对象的所有方法与属性，dir()操作实例就是调用</td>
</tr>
<tr>
<td>__del__()</td>
<td>析构函数，释放对象时调用</td>
</tr>
<tr>
<td>__add__()</td>
<td>+</td>
</tr>
<tr>
<td>__sub__()</td>
<td>-</td>
</tr>
<tr>
<td>__mul__()</td>
<td>*</td>
</tr>
<tr>
<td>__truediv__()</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>__floordiv__()</td>
<td>&#x2F;&#x2F;</td>
</tr>
<tr>
<td>__mod__()</td>
<td>%</td>
</tr>
<tr>
<td>__pow__()</td>
<td>**</td>
</tr>
<tr>
<td>__repr__()</td>
<td>打印,转换</td>
</tr>
<tr>
<td>__setitem__()</td>
<td>按照索引赋值</td>
</tr>
<tr>
<td>__getitem__()</td>
<td>按照索引获取值</td>
</tr>
<tr>
<td>__len__()</td>
<td>计算长度</td>
</tr>
<tr>
<td>__call__()</td>
<td>函数调用</td>
</tr>
<tr>
<td>__contains__()</td>
<td>in</td>
</tr>
<tr>
<td>__eq__()</td>
<td>&#x3D;&#x3D;</td>
</tr>
<tr>
<td>__ne__()</td>
<td>!&#x3D;</td>
</tr>
<tr>
<td>__lt__()</td>
<td>&lt;</td>
</tr>
<tr>
<td>__le__()</td>
<td>&lt;&#x3D;&#x3D;</td>
</tr>
<tr>
<td>__gt__()</td>
<td>&gt;</td>
</tr>
<tr>
<td>__ge__()</td>
<td>&gt;&#x3D;</td>
</tr>
<tr>
<td>__str__()</td>
<td>转换为字符串</td>
</tr>
<tr>
<td>__shift__(), __rshift__()</td>
<td>&lt;&lt;, &gt;&gt;</td>
</tr>
<tr>
<td>__and__(), __or__()</td>
<td>&amp;,</td>
</tr>
<tr>
<td>__invert__(), __xor__()</td>
<td>~, ^</td>
</tr>
<tr>
<td>__iadd__(), __isub__()</td>
<td>+&#x3D;, -&#x3D;</td>
</tr>
</tbody></table>
<h5 id="例子：实现特殊方法-repr-："><a href="#例子：实现特殊方法-repr-：" class="headerlink" title="例子：实现特殊方法__repr__："></a>例子：实现特殊方法__repr__：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## __repr__</span><br><span class="line">class Person:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;hello %s.&quot; % self.name</span><br><span class="line"></span><br><span class="line"> p = Person(&#x27;hkey&#x27;)</span><br><span class="line"></span><br><span class="line"> p</span><br><span class="line"> print(p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义了__repr__方法，不管是直接打印对象还是通过print打印对象，都是走的__repr__中定义的格式。</p>
<p>更多类的特殊方法了解：<a href="https://www.omicsclass.com/article/1033">https://www.omicsclass.com/article/1033</a></p>
<h3 id="2-4-类的继承-选修"><a href="#2-4-类的继承-选修" class="headerlink" title="2.4 类的继承 (选修)"></a>2.4 类的继承 (选修)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#类定义</span><br><span class="line">class people:</span><br><span class="line">    #定义属性</span><br><span class="line">    name = &#x27;&#x27;</span><br><span class="line">    age = 0</span><br><span class="line">    #定义私有属性,私有属性在类外部无法直接进行访问</span><br><span class="line">    __weight = 0</span><br><span class="line">    #定义构造方法</span><br><span class="line">    def __init__(self,n,a,w):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    #定义类方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s speak: I am %d years old.&quot; %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line">#单继承示例</span><br><span class="line">class student(people):</span><br><span class="line">    grade = &#x27;&#x27;</span><br><span class="line">    def __init__(self,n,a,w,g):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    #覆写父类的方法</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(&quot;%s speak: I am %d years old， I am in %d grade of primary school.&quot;%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">s = student(&#x27;ken&#x27;,10,60,3)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Python获取帮助"><a href="#2-5-Python获取帮助" class="headerlink" title="2.5 Python获取帮助"></a>2.5 Python获取帮助</h3><h4 id="Python-官方中文帮助"><a href="#Python-官方中文帮助" class="headerlink" title="Python 官方中文帮助"></a>Python 官方中文帮助</h4><p><a href="https://docs.python.org/zh-cn/3.7/">https://docs.Python.org/zh-cn/3.7/</a></p>
<h4 id="编辑器提供帮助"><a href="#编辑器提供帮助" class="headerlink" title="编辑器提供帮助"></a>编辑器提供帮助</h4><p>pycharm中的documentation内置显示（默认快捷键为Ctrl+Q），选中函数，Ctrl+Q如下：</p>
<p>也有External documetation，快捷键为Shift+F1</p>
<h4 id="陌生类获取类的属性和方法"><a href="#陌生类获取类的属性和方法" class="headerlink" title="陌生类获取类的属性和方法"></a>陌生类获取类的属性和方法</h4><p>dir()函数主要用来查看对象的属性和方法，再去了解这些属性和方法，学习类的使用。</p>
<h4 id="doc-属性查看帮助文档"><a href="#doc-属性查看帮助文档" class="headerlink" title="__doc__属性查看帮助文档"></a>__doc__属性查看帮助文档</h4><p>任务答案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">a.reverse.__doc__</span><br></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;任务答案：&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    a=0</span><br><span class="line">    if x&gt;=0:</span><br><span class="line">        a=x</span><br><span class="line">    else:</span><br><span class="line">        a=0-x</span><br><span class="line">    return a</span><br><span class="line">    </span><br><span class="line">my_abs(-100)</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="3-Python-标准库中包的使用"><a href="#3-Python-标准库中包的使用" class="headerlink" title="3 Python 标准库中包的使用"></a>3 Python 标准库中包的使用</h2><p>python标准库帮助地址：<a href="https://docs.python.org/zh-cn/3.7/library/index.html">https://docs.python.org/zh-cn/3.7/library/index.html</a></p>
<h3 id="3-1-包常见导入方法"><a href="#3-1-包常见导入方法" class="headerlink" title="3.1 包常见导入方法"></a>3.1 包常见导入方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 1 直接导入</span><br><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line">import os,time,sys,re  #每个包之间用逗号隔开；</span><br><span class="line"></span><br><span class="line">#导入的同时改名字</span><br><span class="line">import sys as system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2 导入指定的方法，模块等</span><br><span class="line"></span><br><span class="line">#导入包里面的指定的函数或者类</span><br><span class="line">from os import path</span><br><span class="line">from os import path, walk, unlinkfrom</span><br><span class="line"></span><br><span class="line">#导入包里面所有的内容</span><br><span class="line">from os import *</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些导入的包，其实就是别人写好的代码文件(*.py)，我们导入到我们的程序中就可以直接使用里面的方法，函数，类等，省去自己编写代码的麻烦。如果了解Python包导入的机制，自己也可以写一些包，共享给别人，提供代码的复用性，从而提高我们的开发效率。</p>
<h3 id="3-2-Python-自定义模块导入讲解"><a href="#3-2-Python-自定义模块导入讲解" class="headerlink" title="3.2 Python 自定义模块导入讲解"></a>3.2 Python 自定义模块导入讲解</h3><h4 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h4><p>导入过程首先需要定位导入文件的位置，也就是，告诉Python到何处去找到要导入的文件，因此，需要设置模块的搜索路径。在大多数情况下，Python会自动到默认的目录下去搜索模块；如果要在默认的目录之外导入模块，就需要知道Pyhon搜索模块路径的机制。</p>
<p>Python搜索模块的路径是由四部分构成的：&#x3D;&#x3D;程序的主目录、PATHONPATH目录、标准链接库目录和.pth文件的目录，这四部分的路径都存储在sys.path 列表中。&#x3D;&#x3D;</p>
<h5 id="1，-程序的主目录"><a href="#1，-程序的主目录" class="headerlink" title="1， 程序的主目录"></a>1， 程序的主目录</h5><p>主目录是指程序所在的目录，Python首先会到主目录中搜索模块。</p>
<p>因为主目录总是第一个被搜索，如果模块完全处于主目录中，所有的导入都会自动完成，而不需要单独配置路径。</p>
<h5 id="2，PATHONPATH目录"><a href="#2，PATHONPATH目录" class="headerlink" title="2，PATHONPATH目录"></a>2，PATHONPATH目录</h5><p>PythonPATH目录是指PythonPATH环境变量中配置的目录，是第二个被搜索的目录，Python会从左到右搜索PythonPATH环境变量中设置的所有目录。</p>
<h5 id="3，标准链接库目录"><a href="#3，标准链接库目录" class="headerlink" title="3，标准链接库目录"></a>3，标准链接库目录</h5><p>标准链接库目录是Python按照标准模块的目录，是在安装Python时自动创建的目录，通常不需要添加到PythonPATH目录中。例如：</p>
<h5 id="4，路径文件（-pth文件）"><a href="#4，路径文件（-pth文件）" class="headerlink" title="4，路径文件（.pth文件）"></a>4，路径文件（.pth文件）</h5><p>在模块搜索目录中，创建路径文件，后缀名为.pth，该文件每一行都是一个有效的目录。Python会读取路径文件中的内容，每行都作为一个有效的目录，加载到模块搜索路径列表中。简而言之，当路径文件存放到搜索路径中时，其作用和PYT)HONPATH环境变量的作用相同。</p>
<h3 id="3-3-导入自定义模块指定路径的方法"><a href="#3-3-导入自定义模块指定路径的方法" class="headerlink" title="3.3 导入自定义模块指定路径的方法"></a>3.3 导入自定义模块指定路径的方法</h3><h5 id="方法1：简单不用操作"><a href="#方法1：简单不用操作" class="headerlink" title="方法1：简单不用操作"></a>方法1：简单不用操作</h5><p>把自己写的模块，复制到自己的程序同级目录就可以直接导入；</p>
<h5 id="方法2-函数添加-（临时添加）"><a href="#方法2-函数添加-（临时添加）" class="headerlink" title="方法2: 函数添加  （临时添加）"></a>方法2: 函数添加  （临时添加）</h5><ol>
<li>import sys</li>
<li>查看sys.path</li>
<li>添加sys.path.append(“D:\\perl_script”)</li>
</ol>
<h5 id="方法3-增加-pth文件，推荐！-（永久添加）"><a href="#方法3-增加-pth文件，推荐！-（永久添加）" class="headerlink" title="方法3: 增加.pth文件，推荐！   （永久添加）"></a>方法3: 增加.pth文件，推荐！   （永久添加）</h5><ul>
<li><p>在site-packages目录添加一个文件如mypkpath.pth，必须以.pth为后缀，文件内写上你要加入的模块文件所在的路径，可以添加多行。</p>
</li>
<li><p>如果运行在Windows和Python3.0中，如果Python安装目录的顶层是C:\Users\Administrator\AppData\Local\Programs\Python\Python37，那么可以把自定义的路径文件 mypath.pth 放到该目录中。</p>
</li>
<li><p>也可以放到标准库所在位置的site-packages子目录中（C:\Users\Administrator\AppData\Local\Programs\Python\Python37\Lib\site-packages），来扩展模块的搜搜路径。</p>
</li>
</ul>
<h5 id="方法4-修改环境变量-（永久添加）"><a href="#方法4-修改环境变量-（永久添加）" class="headerlink" title="方法4: 修改环境变量  （永久添加）"></a>方法4: 修改环境变量  （永久添加）</h5><ul>
<li>windows用户可以修改系统环境变量 PYTHONPATH</li>
<li>linux用户也可以添加环境变量 PYTHONPATH</li>
</ul>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>导入自己写的一个模块：</p>
<p>把以下内容存储到文件cars.py中，然后用import导入该模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CAR_num=11</span><br><span class="line"></span><br><span class="line">make=[&quot;Ford&quot;,&quot;Rolls-royce&quot;,&quot;Volkswagen&quot;]</span><br><span class="line"></span><br><span class="line">def mysum( arg1, arg2 ):</span><br><span class="line">   total = arg1 + arg2; # total在这里是局部变量.</span><br><span class="line">   print(&quot;inside  &quot;, total)</span><br><span class="line">   return total;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def das_auto(make=&quot;Volkswagen&quot;, model=&quot;Magotan&quot;, year=2019):</span><br><span class="line">    &#x27;&#x27;&#x27;this function is used to create Volkswagen car&#x27;&#x27;&#x27;</span><br><span class="line">    my_car=Car(&quot;Volkswagen&quot;,&quot;Magotan&quot;,2019)</span><br><span class="line">    return my_car</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#类的定义</span><br><span class="line">class Car:</span><br><span class="line">    &#x27;&#x27;&#x27;this class define a car &#x27;&#x27;&#x27;</span><br><span class="line">    #类属性  共有属性</span><br><span class="line">    wheels=4</span><br><span class="line">    #构造方法</span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        #成员属性</span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.orometer_reading = 0</span><br><span class="line">    #类方法</span><br><span class="line">    def get_description(self):</span><br><span class="line">        long_name = str(self.year) + &#x27; &#x27; + self.make + &#x27; &#x27; + self.model+&quot; &quot;+str(self.wheels)</span><br><span class="line">        return long_name</span><br><span class="line"> </span><br><span class="line">    def read_odometer(self):</span><br><span class="line">        print(&quot;This car has &quot;+ str(self.orometer_reading) + &quot; miles on it&quot;)</span><br><span class="line"> </span><br><span class="line">    def update_orometer(self,miles):</span><br><span class="line">        if miles &gt;= self.orometer_reading:</span><br><span class="line">            self.orometer_reading = miles</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;You can&#x27;troll back an odometer&quot;)</span><br><span class="line"> </span><br><span class="line">    def increase(self,miles):</span><br><span class="line">        self.orometer_reading +=miles</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="小知识-模块和包的区别"><a href="#小知识-模块和包的区别" class="headerlink" title="&#x3D;&#x3D;小知识&#x3D;&#x3D; 模块和包的区别"></a>&#x3D;&#x3D;小知识&#x3D;&#x3D; 模块和包的区别</h5><p>（1）模块：是一个单独的.py文件，用于存放一些功能相关的代码，可以是代码更加容易维护，提高代码的重用价值</p>
<p>（2）包：是一个有层级的目录结构，包含n个模块或者n个子包，包中一定要有__init__.py文件</p>
<h3 id="3-4-Python中-os-sys-time-math包的学习"><a href="#3-4-Python中-os-sys-time-math包的学习" class="headerlink" title="3.4 Python中 os sys time math包的学习"></a>3.4 Python中 os sys time math包的学习</h3><p>os 常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>os.getcwd()</td>
<td>得到当前工作目录，即当前Python脚本工作的目录路径。</td>
</tr>
<tr>
<td>os.mkdir()</td>
<td>方法用于以数字权限模式创建目录，</td>
</tr>
<tr>
<td>os.listdir(path)</td>
<td>返回指定目录下的所有文件和目录名。</td>
</tr>
<tr>
<td>os.walk()</td>
<td>方法用于通过在目录树中游走输出在目录中的文件名，向上或者向下。</td>
</tr>
<tr>
<td>os.remove(path)</td>
<td>方法用来删除一个文件。如果指定的路径是一个目录，将抛出OSError，在Unix, Windows中有效</td>
</tr>
<tr>
<td>os.rmdir(path)</td>
<td>方法用于删除指定路径的目录。仅当这文件夹是空的才可以, 否则, 抛出OSError。</td>
</tr>
<tr>
<td>os.system(command)</td>
<td>函数用来运行shell命令。</td>
</tr>
<tr>
<td>os.linesep</td>
<td>字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。</td>
</tr>
<tr>
<td>os.sep</td>
<td>可以取代操作系统特定的路径分隔符。windows下为 “\\”,linux 下为”&#x2F;“</td>
</tr>
<tr>
<td>os.chdir(dirname)</td>
<td>改变工作目录到dirname</td>
</tr>
<tr>
<td>os.path.isfile(path)</td>
<td>方法分别检验给出的路径是否一个文件，输入路径必须是绝对路径。</td>
</tr>
<tr>
<td>os.path.isdir(path)</td>
<td>方法检验给出的路径是否一个目录，输入路径必须绝对路径。</td>
</tr>
<tr>
<td>os.path.exists()</td>
<td>方法用来检验给出的路径是否真地存在</td>
</tr>
<tr>
<td>os.path.join(path,name)</td>
<td>连接目录与文件名或目录;使用“\”连接</td>
</tr>
<tr>
<td>os.path.basename(path)</td>
<td>返回文件名</td>
</tr>
<tr>
<td>os.path.dirname(path)</td>
<td>返回文件路径</td>
</tr>
<tr>
<td>os.path.abspath(name)</td>
<td>获得绝对路径</td>
</tr>
<tr>
<td>os.path.getsize(name)</td>
<td>获得文件大小</td>
</tr>
<tr>
<td>os.path.split(path)</td>
<td>将path分割成目录和文件名二元组返回。</td>
</tr>
<tr>
<td>os.path.splitext()</td>
<td>分离文件名与扩展名</td>
</tr>
</tbody></table>
<h4 id="包使用示例代码"><a href="#包使用示例代码" class="headerlink" title="包使用示例代码"></a>包使用示例代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#遍历一个目录，获得所有文件的路径</span><br><span class="line"></span><br><span class="line">import os  </span><br><span class="line">os.chdir(&quot;D:\Python_script&quot;)</span><br><span class="line">cwd = os.getcwd()  </span><br><span class="line">for dir_path, dir_names, file_names in os.walk(cwd): </span><br><span class="line">    for file_name in file_names:    </span><br><span class="line">        p=os.path.join(dir_path,file_name)</span><br><span class="line">        print(p)</span><br><span class="line">    for dir_name in dir_names:</span><br><span class="line">        p=os.path.join(dir_path,dir_name)</span><br><span class="line">        print(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#windows系统中调用命令</span><br><span class="line">os.system(&#x27;copy a.v b.v&#x27;)</span><br><span class="line">os.system(&#x27;del b.v&#x27;)</span><br><span class="line">os.system(&#x27;rename a.v b.v&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#linux系统中调用命令</span><br><span class="line">os.system(&#x27;cp a.v b.v&#x27;)</span><br><span class="line">os.system(&#x27;rm b.v&#x27;)</span><br><span class="line">os.system(&#x27;mv a.v b.v&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="sys包常用属性或者方法"><a href="#sys包常用属性或者方法" class="headerlink" title="sys包常用属性或者方法"></a>sys包常用属性或者方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sys.argv</td>
<td>命令行参数List，第一个元素是程序本身路径</td>
</tr>
<tr>
<td>sys.exit(n)</td>
<td>退出程序，正常退出时exit(0)</td>
</tr>
<tr>
<td>sys.version</td>
<td>获取Python解释程序的版本信息</td>
</tr>
<tr>
<td>sys.modules</td>
<td>返回系统导入的模块字段，key是模块名，value是模块</td>
</tr>
<tr>
<td>sys.path</td>
<td>返回模块的搜索路径，初始化时使用PythonPATH环境变量的值</td>
</tr>
<tr>
<td>sys.stdout</td>
<td>标准输出</td>
</tr>
<tr>
<td>sys.stdin</td>
<td>标准输入</td>
</tr>
<tr>
<td>sys.stderr</td>
<td>错误输出</td>
</tr>
</tbody></table>
<h4 id="math-常用属性和方法"><a href="#math-常用属性和方法" class="headerlink" title="math 常用属性和方法"></a>math 常用属性和方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>math.e</td>
<td>自然常数e</td>
<td>&gt;&gt;&gt; math.e</td>
</tr>
<tr>
<td>math.pi</td>
<td>圆周率pi</td>
<td>&gt;&gt;&gt; math.pi</td>
</tr>
<tr>
<td>math.log10(x)</td>
<td>返回x的以10为底的对数</td>
<td>&gt;&gt;&gt; math.log10(2)</td>
</tr>
<tr>
<td>math.pow(x, y)</td>
<td>返回x的y次方</td>
<td>&gt;&gt;&gt; math.pow(5,3)</td>
</tr>
<tr>
<td>math.sqrt(x)</td>
<td>返回x的平方根</td>
<td>&gt;&gt;&gt; math.sqrt(3)</td>
</tr>
<tr>
<td>math.ceil(x)</td>
<td>返回不小于x的整数</td>
<td>&gt;&gt;&gt; math.ceil(5.2)</td>
</tr>
<tr>
<td>math.floor(x)</td>
<td>返回不大于x的整数</td>
<td>&gt;&gt;&gt; math.floor(5.8)</td>
</tr>
<tr>
<td>math.fabs(x)</td>
<td>返回x的绝对值</td>
<td>&gt;&gt;&gt; math.fabs(-5)</td>
</tr>
</tbody></table>
<hr>
<p>练习：<br>将文件打开然后，批量的合并到一个文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fw=open(&quot;all.fa&quot;,&quot;w&quot;)</span><br><span class="line">for i in os.listdir(os.getcwd()):</span><br><span class="line">    if i.endswith(&quot;fa&quot;):</span><br><span class="line">        f=open(i,&quot;r&quot;)</span><br><span class="line">        for line in f:</span><br><span class="line">            fw.write(line)</span><br><span class="line">        f.close()</span><br><span class="line">fw.close() </span><br></pre></td></tr></table></figure>


<h2 id="4-正则表达式："><a href="#4-正则表达式：" class="headerlink" title="4 正则表达式："></a>4 正则表达式：</h2><h3 id="4-1-了解正则表达式"><a href="#4-1-了解正则表达式" class="headerlink" title="4.1 了解正则表达式"></a>4.1 了解正则表达式</h3><p>正则表达式是用于处理字符串（String）的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；</p>
<h4 id="正则表达式功能"><a href="#正则表达式功能" class="headerlink" title="正则表达式功能"></a>正则表达式功能</h4><ul>
<li>查找&#x2F;匹配               </li>
<li>替换                          </li>
<li>捕获</li>
<li>计数</li>
</ul>
<h4 id="正则表达式通配符"><a href="#正则表达式通配符" class="headerlink" title="正则表达式通配符"></a>正则表达式通配符</h4><ul>
<li>通配符是特殊字符，在正则表达式中有特殊意义</li>
<li>直接的单词或者数字是原样匹配</li>
</ul>
<h4 id="常见通配符学习"><a href="#常见通配符学习" class="headerlink" title="常见通配符学习"></a>常见通配符学习</h4><table>
<thead>
<tr>
<th>模式匹配通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的末尾。</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td>[…]</td>
<td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’，[a-zA-Z0-9]</td>
</tr>
<tr>
<td>[^…]</td>
<td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母数字及下划线</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母数字及下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空白字符，等价于 [\t\n\r\f].</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意非空字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任意数字，等价于 [0-9].</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或多个的表达式,如:be*:  b, be,beeeee, bee。</td>
</tr>
<tr>
<td>+</td>
<td>匹配1个或多个的表达式,如: be+ : be,beeeee, bee。</td>
</tr>
<tr>
<td>?</td>
<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 .如  bo? 只能匹配：b,bo</td>
</tr>
<tr>
<td>{ n}</td>
<td>精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{ n,}</td>
<td>匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td>
</tr>
<tr>
<td>{ n, m}</td>
<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td>|</td>
<td>或者的意思，如：a| b  匹配a或b</td>
</tr>
<tr>
<td>()</td>
<td>对正则表达式分组并记住匹配的文本,正则表达式捕获功能</td>
</tr>
</tbody></table>
<h5 id="选修内容"><a href="#选修内容" class="headerlink" title="选修内容"></a>选修内容</h5><table>
<thead>
<tr>
<th>模式匹配通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(?imx)</td>
<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?-imx)</td>
<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?: re)</td>
<td>类似 (…), 但是不表示一个组</td>
</tr>
<tr>
<td>(?imx: re)</td>
<td>在括号中使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?-imx: re)</td>
<td>在括号中不使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?#…)</td>
<td>注释.</td>
</tr>
<tr>
<td>(?&#x3D; re)</td>
<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td>(?! re)</td>
<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>
</tr>
<tr>
<td>(?&gt; re)</td>
<td>匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td>\A</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td>
</tr>
<tr>
<td>\z</td>
<td>匹配字符串结束</td>
</tr>
<tr>
<td>\G</td>
<td>匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>\n, \t, 等.</td>
<td>匹配一个换行符。匹配一个制表符。等</td>
</tr>
<tr>
<td>\1…\9</td>
<td>匹配第n个分组的内容。</td>
</tr>
<tr>
<td>\10</td>
<td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td>
</tr>
</tbody></table>
<h3 id="4-2-正则表达式实操学习"><a href="#4-2-正则表达式实操学习" class="headerlink" title="4.2 正则表达式实操学习"></a>4.2 正则表达式实操学习</h3><p><a href="https://regexone.com/">https://regexone.com/</a></p>
<h4 id="正则表达式练习"><a href="#正则表达式练习" class="headerlink" title="正则表达式练习"></a>正则表达式练习</h4><ul>
<li>应用 notepad++ 或者editplus 软件 正则表达式处理文本</li>
<li>不足之处-&gt;无法处理大文件（内存限制）</li>
</ul>
<h5 id="练习要求："><a href="#练习要求：" class="headerlink" title="练习要求："></a>练习要求：</h5><ul>
<li>处理要求1：把序列转换成一行；</li>
<li>处理要求2：把一行的序列文件再转换回来；</li>
</ul>
<p>处理文件内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;NP_651973.4 nbs, isoform E [Drosophila melanogaster]</span><br><span class="line">MFVLTKDDEKFVLFPGKKVYTIGRLATDLIVAQDLSISRNHAQLLIQTEADGDDTLHIEDLGSRYGTFIF</span><br><span class="line">PKNSQKPRKVPAKTSTPLPVGTRLRFGANMSIWQVTQLKLVTTVSALTRSEVQELTKMLEPMGGTVTSNW</span><br><span class="line">TEECSHLTMNEVSVTVKLLHAMLENKPIVTFPYWRKMLQAAQSIHVKEGWPQPEDYQPTNIDVTWRPERT</span><br><span class="line">RLFAGKTFVFMNRKHFDMYGSVVQKAGATCKDINSGVRKTFLTKSDVIVIQYVPSSQSQATESINSIQDR</span><br><span class="line">YILEQNGRRIIQEYEIGMALIHCSITEFCNPTHKFISDSLPTTESVTSSMAFNSSIIVPNTERHSAQSNA</span><br><span class="line">TPISELVVPESIECEMEQDASKPHSEDQASLRKRSHASTVDSSDEEKKSTLSKRAKSDIATKLTMKSKNA</span><br><span class="line">ILLDSSLEEDVTPAPAPAPVQRVTRQSKAIAEEKSVHPPVPAASKHITRKTKQVFCVDSSDEENENARKP</span><br><span class="line">KETPAPTIPSMAKKKTEAPVATRISPRLNGKSLATNITNQPADKHAVPAKRPVLSVASSDEEDEGDLFQF</span><br><span class="line">RKSPQKPAETVVQPRIAGKGNAPARISVVDFLEKSQAQEPAPVPPQLESQSQTQPRKRLRLELLNESDSD</span><br><span class="line">DCDNLFNFADSKKKRKTQEAQRNDDSTDGLFNFNSERPSDHDDEDSRLTEPFVPETESKKQSKYIVAPRR</span><br><span class="line">DRPKKVDISGWLSCSRLNDNIKSEIDADSVKMETSIKADPDEEQWLAAMKDSIEVRMCNLNIVIRSQEEV</span><br><span class="line">DASLEDSVNKHGGRKNFKKFVKTKNPHPQKRIVALKSLRLADGMVTCV</span><br><span class="line"></span><br><span class="line">&gt;AIQ85043.1 NBS-LRR disease resistance protein, partial [Musa ABB Group]</span><br><span class="line">MGGVGKTTLAQQAYNPERVKDYFHHKVWVCVSDNFNVERLSKEIIESITENKCDLSNLDTLQVVVKKKLT</span><br><span class="line">SKRFLLVLDDVWNEDSLKWERFCAPLRYGEPGSKILVTTRSKKIAEMVGNPFPLGGLDEASYWKLFKKCA</span><br><span class="line">FGSEYAGE</span><br><span class="line"></span><br><span class="line">&gt;AIQ85044.1 NBS-LRR disease resistance protein, partial [Musa laterita]</span><br><span class="line">GGGGKTSLAQQAYNHERVKDYFHHKVWVCVSDNFNVERLTKEIIESLTRNKWDLNNLDTLQVVVKEELTS</span><br><span class="line">KRFLLVLDDVWNEDSLKWERFCAPLRYGEPGSKILVTTRSKKIAEMVGNPIPLGGLDEASYWELFKKCAF</span><br><span class="line">GSEDAGE</span><br><span class="line"></span><br><span class="line">&gt;AIQ85045.1 NBS-LRR disease resistance protein, partial [Musa laterita]</span><br><span class="line">MGGVGKTTLAQQAYNHERVQDYFQHEVWVCVSDNFNVERLTKEIIESITENKCDLSNLDTLQVVLKKNLT</span><br><span class="line">SKRFLLVLDDVWNEDSLKWERFCAPLRYGEPGSKILVTTRSKNVFENGWNPIPLGGLDEASYWKLFKKCA</span><br><span class="line">FGSEDAGEFPHLE</span><br><span class="line"></span><br><span class="line">&gt;AAM28915.1 NBS, partial [Pinus taeda]</span><br><span class="line">TRFDWKEQLHRLQHVLPSETQEKLXFGYLNLNREERQMFLDSACFFIGQKRDTAIRIWEGSLWDGHSGFL</span><br><span class="line">TLQHRCLLGVDDENNIEXHDHLRDFGRAACPNRFLPSWIPMDSLRVLQVSGSVLKTLWEDDSQPPLQLRE</span><br><span class="line">LEINAPLSNIPGSIGRLKHLERFVVGKYLSGQVNLTELPVEFCHLQSLKALVLTECSKIKSLPEFGALLM</span><br><span class="line">WLRHIDLSFCRNLERLPDSLHYLSHLRLINLSDCHDLVTLPDNIGRLRCLQHIDLQGCHNLERLPDSFGE</span><br><span class="line">LTDLRHINLSGCHDLQRLPDSFGKLRYLQHIDLHGCHSLEGLPISFGDLMNLEYINLSNCHNLERLPESI</span><br><span class="line">GNLSDLRHIDLSGCHNLERLPDNFRELEELRYLDVEGCSNLIIDRFEIIGISDNLPVAHQVNWNKY</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Python中正则表达式re包"><a href="#4-3-Python中正则表达式re包" class="headerlink" title="4.3 Python中正则表达式re包"></a>4.3 Python中正则表达式re包</h3><p>&#x3D;&#x3D;新包学习思路总结：&#x3D;&#x3D;</p>
<ol>
<li>学习里面的函数&#x2F;方法</li>
<li>类实例化后对象的学习(方法，属性)</li>
<li>都有哪些类，类之间的关系</li>
</ol>
<h4 id="re包中常用方法"><a href="#re包中常用方法" class="headerlink" title="re包中常用方法"></a>re包中常用方法</h4><ol>
<li>re.search(pattern, string, flags&#x3D;0)</li>
<li>re.match(pattern, string, flags&#x3D;0)</li>
<li>re.findall(pattern, string, flags&#x3D;0)</li>
</ol>
<p>参数说明</p>
<ul>
<li>pattern	匹配的正则表达式</li>
<li>string	要匹配的字符串。</li>
<li>flags	用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。见：正则表达式修饰符</li>
</ul>
<h3 id="注意区别："><a href="#注意区别：" class="headerlink" title="注意区别："></a>注意区别：</h3><p><strong>re.match与re.search的区别</strong><br>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>
<p><strong>re.match和re.search 与findall的区别：</strong><br>前面两个找到一个就结束，findall会找到所有。<br>返回对象不同，findall返回列表，</p>
<h4 id="正则表达式修饰符-可选标志"><a href="#正则表达式修饰符-可选标志" class="headerlink" title="正则表达式修饰符 - 可选标志"></a>正则表达式修饰符 - 可选标志</h4><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>re.I</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>re.M</td>
<td>多行匹配，影响 ^ 和 $</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别（locale-aware）匹配</td>
</tr>
<tr>
<td>re.S</td>
<td>使 . 匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.X</td>
<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">line = &quot;Cats are smarter than dogs&quot;</span><br><span class="line"> </span><br><span class="line">matchObj = re.match( r&#x27;dogs&#x27;, line, re.I)</span><br><span class="line">if matchObj:</span><br><span class="line">   print(&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())</span><br><span class="line">else:</span><br><span class="line">   print (&quot;No match!!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line = &quot;Cats are smarter than Dogs&quot;</span><br><span class="line">matchObj = re.search( r&#x27;dogs&#x27;, line, re.I)</span><br><span class="line">if matchObj:</span><br><span class="line">   print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())</span><br><span class="line">else:</span><br><span class="line">   print (&quot;No match!!&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="匹配对象的方法-得到详细的搜索匹配结果"><a href="#匹配对象的方法-得到详细的搜索匹配结果" class="headerlink" title="匹配对象的方法  得到详细的搜索匹配结果"></a>匹配对象的方法  得到详细的搜索匹配结果</h4><ul>
<li>group() 返回被 RE 匹配的字符串。</li>
<li>start() 返回匹配开始的位置</li>
<li>end() 返回匹配结束的位置</li>
<li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li>
</ul>
<p>更多方法及帮助：<a href="https://docs.python.org/zh-cn/3.7/library/re.html#match-objects">https://docs.python.org/zh-cn/3.7/library/re.html#match-objects</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line = &quot;Cats are smarter than dogs&quot;;</span><br><span class="line"> </span><br><span class="line">searchObj = re.search( r&#x27;(.*) are (.*?) .*&#x27;, line, re.M|re.I)</span><br><span class="line"> </span><br><span class="line">if searchObj:</span><br><span class="line">   print &quot;searchObj.group() : &quot;, searchObj.group()</span><br><span class="line">   print &quot;searchObj.group(1) : &quot;, searchObj.group(1)</span><br><span class="line">   print &quot;searchObj.group(2) : &quot;, searchObj.group(2)</span><br><span class="line">else:</span><br><span class="line">   print &quot;Nothing found!!&quot;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">print(re.search(&#x27;www&#x27;, &#x27;www.omicsclass.com&#x27;).span())  # 在起始位置匹配</span><br><span class="line">print(re.search(&#x27;com&#x27;, &#x27;www.omicsclass.com&#x27;).span())         # 不在起始位置匹配   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>


<h4 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h4><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。支持正则表达式，比字符串自带的replace方法功能更强大。</p>
<p>语法：</p>
<blockquote>
<p>re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)</p>
</blockquote>
<ul>
<li>pattern : 正则中的模式字符串。 (搜索的内容)</li>
<li>repl : 替换的字符串，也可为一个函数。 (替换的内容)</li>
<li>string : 要被查找替换的原始字符串。 (在哪里搜索替换)</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
<li>flags	用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。见：正则表达式修饰符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">tel = &quot;010-8054-3251,www.omicsclasss.com&quot;</span><br><span class="line"></span><br><span class="line"># 删除字符串中的 数字 </span><br><span class="line">num = re.sub(r&quot;^\d+-\d+-\d+,&quot;, &quot;&quot;, tel)</span><br><span class="line">print(&quot;Website is:&quot;, num)</span><br><span class="line"> </span><br><span class="line"># 删除数字</span><br><span class="line">num = re.sub(r&#x27;\d+&#x27;, &quot;&quot;, tel)</span><br><span class="line">print(&quot;telphone num : &quot;, num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 高级用法 （选修）</span><br><span class="line">#repl 参数是一个函数</span><br><span class="line">#以下实例中将字符串中的匹配的数字乘以 2：</span><br><span class="line"></span><br><span class="line"># 将匹配的数字乘以 2</span><br><span class="line">def double(matched):</span><br><span class="line">    value = int(matched.group(&#x27;value&#x27;))</span><br><span class="line">    return str(value * 2)</span><br><span class="line"> </span><br><span class="line">s = &#x27;A23G4HFD567&#x27;</span><br><span class="line">print(re.sub(&#x27;(?P&lt;value&gt;\d+)&#x27;, double, s))</span><br></pre></td></tr></table></figure>
<h4 id="re-split-方法支持正则表达式："><a href="#re-split-方法支持正则表达式：" class="headerlink" title="re.split 方法支持正则表达式："></a>re.split 方法支持正则表达式：</h4><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p>
<blockquote>
<p>re.split(pattern, string[, maxsplit&#x3D;0, flags&#x3D;0])</p>
</blockquote>
<ul>
<li>pattern	匹配的正则表达式</li>
<li>string	要分割的字符串。</li>
<li>maxsplit	分隔次数，maxsplit&#x3D;1 分隔一次，默认为 0，不限制次数。</li>
<li>flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">re.split(r&#x27;[,;=]&#x27;, &#x27;omicsclass, omicsclass;omicsclass.&#x27;)</span><br><span class="line">re.split(r&#x27;\s+&#x27;, &#x27; omicsclass, omicsclass, omicsclass.&#x27;) </span><br><span class="line">re.split(r&#x27;,&#x27;, &#x27; omicsclass, omicsclass, omicsclass.&#x27;, 1) </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">re.split(r&#x27;\t&#x27;, &#x27;hello world&#x27;)   # 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span><br><span class="line">[&#x27;hello world&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="re-compile-方法"><a href="#re-compile-方法" class="headerlink" title="re.compile 方法"></a>re.compile 方法</h4><p>compile 方法用于编译正则表达式，提前编译后的正则表达式可以加快正则表示的匹配速度；编译后生成一个正则表达式（ Pattern ）对象。</p>
<p>语法格式为：</p>
<blockquote>
<p>re.compile(pattern[, flags])</p>
</blockquote>
<ul>
<li>pattern : 一个字符串形式的正则表达式</li>
<li>flags	用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。见：正则表达式修饰符</li>
</ul>
<h5 id="Pattern正则表达式对象-（正则对象）"><a href="#Pattern正则表达式对象-（正则对象）" class="headerlink" title="Pattern正则表达式对象 （正则对象）"></a>Pattern正则表达式对象 （正则对象）</h5><p>常见方法：</p>
<ul>
<li>Pattern.findall(string[, pos[, endpos]])</li>
<li>Pattern.search(string[, pos[, endpos]])</li>
<li>Pattern.match(string[, pos[, endpos]])</li>
</ul>
<p>参数：</p>
<ul>
<li>string : 待匹配的字符串。</li>
<li>pos : 可选参数，指定字符串的起始位置，默认为 0。</li>
<li>endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li>
</ul>
<p>注意： match 和 search 是匹配一次 findall 匹配所有。</p>
<p>更多方法：<a href="https://docs.python.org/zh-cn/3.7/library/re.html#regular-expression-objects">https://docs.python.org/zh-cn/3.7/library/re.html#regular-expression-objects</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">p = re.compile(r&#x27;\d+&#x27;)   # 查找数字</span><br><span class="line">result1 = p.findall(&#x27;omicsclass 123 google 456&#x27;)</span><br><span class="line">result2 = p.findall(&#x27;runomicsclass123google456&#x27;, 0, 10)</span><br><span class="line"> </span><br><span class="line">print(result1)</span><br><span class="line">print(result2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result3=p.search(&quot;runomicsclass123google456&quot;)</span><br><span class="line">result4=p.match(&quot;runomicsclass123google456&quot;)</span><br><span class="line"></span><br><span class="line">print(result3)</span><br><span class="line">print(result4)</span><br><span class="line"></span><br><span class="line">#或者也可以这样用</span><br><span class="line">result5=re.search(p,&quot;runomicsclass123google456&quot;)</span><br><span class="line">result6=re.match(p,&quot;runomicsclass123google456&quot;)</span><br><span class="line"></span><br><span class="line">print(result5)</span><br><span class="line">print(result6)</span><br></pre></td></tr></table></figure>



<h4 id="正则表达式处理文件主要用处"><a href="#正则表达式处理文件主要用处" class="headerlink" title="正则表达式处理文件主要用处"></a>正则表达式处理文件主要用处</h4><ol>
<li>split分隔文件</li>
<li>查找是否含有某某字符，配合IF判断</li>
<li>在字符串中捕获信息</li>
</ol>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>从GFF文件中提取基因ID及位置信息存成表格(注意用正则表达式的捕获功能完成)</p>
<p>GFF 文件（人1号染色体上基因注释信息）地址：<a href="ftp://ftp.ensembl.org/pub/release-98/gff3/homo_sapiens/Homo_sapiens.GRCh38.98.chromosome.1.gff3.gz">ftp://ftp.ensembl.org/pub/release-98/gff3/homo_sapiens/Homo_sapiens.GRCh38.98.chromosome.1.gff3.gz</a></p>
<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">fr=open(&quot;D:\\python_script\\Homo_sapiens.GRCh38.98.chromosome.1.gff3\\Homo_sapiens.GRCh38.98.chromosome.1.gff3&quot;,&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">fw=open(&quot;D:\\python_script\\chr1.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">for line in fr:</span><br><span class="line">    if re.match(&quot;#&quot;,line):</span><br><span class="line">        continue</span><br><span class="line">        </span><br><span class="line">    tmp=re.split(&quot;\t&quot;,line)</span><br><span class="line">    if tmp[2] == &quot;gene&quot;:</span><br><span class="line">        mobj=re.search(&quot;ID=gene:([^;]+)&quot;,tmp[8]) #捕获基因ID</span><br><span class="line">        if mobj:</span><br><span class="line">            fw.write(&quot;\t&quot;.join([tmp[0],tmp[3],tmp[4],tmp[6],mobj.group(1)])+&quot;\n&quot;)</span><br><span class="line">            </span><br><span class="line">fr.close()</span><br><span class="line">fw.close()</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<hr>
<h2 id="5-Python-biopython包处理生物数据"><a href="#5-Python-biopython包处理生物数据" class="headerlink" title="5 Python biopython包处理生物数据"></a>5 Python biopython包处理生物数据</h2><h3 id="5-1-BioPython包"><a href="#5-1-BioPython包" class="headerlink" title="5.1 BioPython包"></a>5.1 BioPython包</h3><p><img src="https://note.youdao.com/yws/api/group/92990402/noteresource/85ACA824149943D8B82329A6CD4541D8/version/1464?method=get-resource&shareToken=08DB9C16FB6D47AA8EBD104017423D2D&entryId=446741437" alt="image"></p>
<p>专门用于处理生物数据的包，主要功能如下：</p>
<h4 id="（1）biopython处理生物数据"><a href="#（1）biopython处理生物数据" class="headerlink" title="（1）biopython处理生物数据"></a>（1）biopython处理生物数据</h4><ul>
<li>Blast output – both from standalone and WWW Blast</li>
<li>Clustalw</li>
<li>FASTA&#x2F;FASTQ</li>
<li>GenBank</li>
<li>PubMed and Medline</li>
<li>ExPASy files, like Enzyme and Prosite</li>
<li>SCOP, including ‘dom’ and ‘lin’ files</li>
<li>UniGene</li>
<li>SwissProt</li>
</ul>
<h4 id="（2）在线链接生物数据库，实时处理数据"><a href="#（2）在线链接生物数据库，实时处理数据" class="headerlink" title="（2）在线链接生物数据库，实时处理数据"></a>（2）在线链接生物数据库，实时处理数据</h4><ul>
<li>NCBI – Blast, Entrez and PubMed services</li>
<li>ExPASy – Swiss-Prot and Prosite entries, as well as Prosite searches</li>
</ul>
<h4 id="（3）与生物信息常用软件交户，实现批量处理分析数据"><a href="#（3）与生物信息常用软件交户，实现批量处理分析数据" class="headerlink" title="（3）与生物信息常用软件交户，实现批量处理分析数据"></a>（3）与生物信息常用软件交户，实现批量处理分析数据</h4><ul>
<li>Standalone Blast from NCBI</li>
<li>Clustalw alignment program</li>
<li>EMBOSS command line tools</li>
</ul>
<h4 id="获取帮助："><a href="#获取帮助：" class="headerlink" title="获取帮助："></a>获取帮助：</h4><p>官方网站：<a href="https://biopython.org/">https://biopython.org/</a></p>
<p>帮助文档：<a href="http://biopython.org/DIST/docs/tutorial/Tutorial.pdf">http://biopython.org/DIST/docs/tutorial/Tutorial.pdf</a></p>
<p>中文帮助文档（Last Update – 22 March 2013 (Biopython 1.61+)）：<a href="https://biopython-cn.readthedocs.io/zh_CN/latest/">https://biopython-cn.readthedocs.io/zh_CN/latest/</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install biopython -i  https://pypi.tuna.tsinghua.edu.cn/simple #安装</span><br><span class="line">pip install --upgrade biopython  #更新</span><br><span class="line">pip uninstall biopython  #卸载</span><br><span class="line"></span><br><span class="line">#导入包：</span><br><span class="line">import Bio</span><br></pre></td></tr></table></figure>
<h3 id="5-2-利用biopython处理序列-fasta，fastq等"><a href="#5-2-利用biopython处理序列-fasta，fastq等" class="headerlink" title="5.2 利用biopython处理序列(fasta，fastq等)"></a>5.2 利用biopython处理序列(fasta，fastq等)</h3><h4 id="Seq序列对象与SeqRecord注释对象学习"><a href="#Seq序列对象与SeqRecord注释对象学习" class="headerlink" title="Seq序列对象与SeqRecord注释对象学习"></a>Seq序列对象与SeqRecord注释对象学习</h4><p><strong>Seq对象中文帮助：</strong> <a href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr03.html#chapter-bio-seq">https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr03.html#chapter-bio-seq</a></p>
<p><strong>SeqRecord注释对象中文帮助：</strong> <a href="https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr04.html#chapter-seqrecord">https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr04.html#chapter-seqrecord</a></p>
<h4 id="5-2-1-Seq序列对象"><a href="#5-2-1-Seq序列对象" class="headerlink" title="5.2.1 Seq序列对象"></a>5.2.1 Seq序列对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">from Bio.Alphabet import IUPAC</span><br><span class="line">from Bio.SeqUtils import GC</span><br><span class="line"></span><br><span class="line">#Seq 对象创建</span><br><span class="line">dna_seq = Seq(&quot;AGTACACTGGT&quot;, IUPAC.unambiguous_dna)</span><br><span class="line">protein_seq = Seq(&quot;EVRNAK&quot;, IUPAC.protein)</span><br><span class="line"></span><br><span class="line">#序列对象继承了字符串对象一些方法</span><br><span class="line">len(dna_seq)</span><br><span class="line">dna_seq.count(&quot;A&quot;)</span><br><span class="line">GC(dna_seq)  #计算GC含量</span><br><span class="line">dna_seq[4:12] #切取序列</span><br><span class="line">str(dna_seq)  #将序列对象转换成字符串</span><br><span class="line">my_seq = Seq(&quot;ACGT&quot;, IUPAC.unambiguous_dna)</span><br><span class="line">my_seq + dna_seq  #连接或添加序列</span><br><span class="line">my_seq.upper()  </span><br><span class="line">my_seq.lower()</span><br><span class="line"></span><br><span class="line">#核苷酸序列反向互补序列            </span><br><span class="line">my_seq.reverse_complement()  </span><br><span class="line"></span><br><span class="line">#转录</span><br><span class="line">coding_dna = Seq(&quot;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&quot;, IUPAC.unambiguous_dna)</span><br><span class="line">messenger_rna = coding_dna.transcribe()</span><br><span class="line">messenger_rna.back_transcribe()  #从mRNA逆向转录为DNA编码链的方法</span><br><span class="line"></span><br><span class="line">#翻译  https://biopython-cn.readthedocs.io/zh_CN/latest/cn/chr03.html#sec-translation</span><br><span class="line">coding_dna.translate()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Bio.Alphabet.IUPAC 提供了蛋白质、DNA和RNA的基本定义：</p>
<ul>
<li>IUPAC.protein  蛋白质</li>
<li>IUPAC.unambiguous_dna  DNA</li>
</ul>
<p>更多编码见：<a href="https://www.omicsclass.com/article/409">https://www.omicsclass.com/article/409</a></p>
<h4 id="5-2-2-SeqRecord序列注释对象"><a href="#5-2-2-SeqRecord序列注释对象" class="headerlink" title="5.2.2 SeqRecord序列注释对象"></a>5.2.2 SeqRecord序列注释对象</h4><p>SeqRecord 类非常简单,包括下列属性:</p>
<p><strong>.seq</strong><br>– 序列自身（即 Seq 对象）。</p>
<p><strong>.id</strong><br>– 序列主ID（-字符串类型）。通常类同于accession number。</p>
<p><strong>.description</strong><br>– 序列描述（-字符串类型）。</p>
<p><strong>.name</strong><br>– 序列名&#x2F;id （-字符串类型）。 可以是accession number, 也可是clone名（类似GenBank record中的LOCUS id）。</p>
<p><strong>.letter_annotations</strong><br>– 对照序列的每个字母逐字注释（per-letter-annotations），以信息名为键（keys），信息内容为值（value）所构成的字典。值与序列等长，用Python列表、元组或字符串表示。.letter_annotations可用于质量分数(如第 18.1.6 节) 或二级结构信息 (如 Stockholm&#x2F;PFAM 比对文件)等数据的存储。</p>
<p><strong>.annotations</strong><br>– 用于储存附加信息的字典。信息名为键（keys），信息内容为值（value）。用于保存序列的零散信息（如unstructured information）。</p>
<p><strong>.features</strong><br>– SeqFeature 对象列表，储存序列的结构化信息（structured information），如：基因位置, 蛋白结构域。</p>
<p><strong>.dbxrefs</strong><br>– 储存数据库交叉引用信息（cross-references）的字符串列表。</p>
<h4 id="SeqRecord对象创建"><a href="#SeqRecord对象创建" class="headerlink" title="SeqRecord对象创建"></a>SeqRecord对象创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">from Bio.Alphabet import IUPAC</span><br><span class="line"></span><br><span class="line">simple_seq = Seq(&quot;CCCTTCTTGTCTTCAGCGTTTCTCC&quot;, IUPAC.unambiguous_dna)</span><br><span class="line">simple_seq_r = SeqRecord(simple_seq, id=&quot;AC12345&quot;,description=&quot;just a test sequence&quot;)</span><br><span class="line"></span><br><span class="line">#属性后添加和修改</span><br><span class="line">simple_seq_r.description = &quot;just a test sequence&quot;</span><br><span class="line"></span><br><span class="line">simple_seq_r.seq</span><br><span class="line">simple_seq_r.id</span><br><span class="line">simple_seq_r.description</span><br><span class="line"></span><br><span class="line">#如果是fastq文件，可以添加序列质量值注释信息</span><br><span class="line"></span><br><span class="line">simple_seq_r.letter_annotations[&quot;phred_quality&quot;] = [26, 26, 18, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 22, 26, 26, 26, 26,</span><br><span class="line">26, 26, 26, 23, 23]</span><br><span class="line">print(simple_seq_r.letter_annotations)</span><br><span class="line">print(simple_seq_r.letter_annotations[&quot;phred_quality&quot;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#序列截取：</span><br><span class="line"></span><br><span class="line">simple_seq_r[0:2]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SeqRecord对象从文件中获得"><a href="#SeqRecord对象从文件中获得" class="headerlink" title="SeqRecord对象从文件中获得"></a>SeqRecord对象从文件中获得</h4><p>fasta&#x2F;fastq文件读写，得到SeqRecord对象；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#fasta文件读取得到SeqRecord对象</span><br><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">from Bio import SeqIO</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.chdir(&quot;D:\\python_script&quot;)</span><br><span class="line">output_handle = open(&quot;out.fa&quot;, &quot;w&quot;)</span><br><span class="line">for rec in SeqIO.parse(&quot;test.fa&quot;, &quot;fasta&quot;):</span><br><span class="line">    seq=rec.seq</span><br><span class="line">    seq_r = SeqRecord(seq[0:10],id=rec.id,description=rec.description)</span><br><span class="line">    SeqIO.write(seq_r, output_handle, &quot;fasta&quot;)</span><br><span class="line"></span><br><span class="line">output_handle.close()</span><br></pre></td></tr></table></figure>
<h4 id="5-3-练习"><a href="#5-3-练习" class="headerlink" title="5.3 练习"></a>5.3 练习</h4><h5 id="任务：利用biopython处理fasta-fastq序列"><a href="#任务：利用biopython处理fasta-fastq序列" class="headerlink" title="任务：利用biopython处理fasta&#x2F;fastq序列"></a>任务：利用biopython处理fasta&#x2F;fastq序列</h5><ol>
<li>任务: 提取指定ID的fasta序列</li>
<li>任务: 截取fasta序列中指定位置的序列</li>
<li>任务: fastq文件转换成fasta文件</li>
<li>任务: fastq文件去掉前5个碱基</li>
</ol>
<p>fa文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;AT1G66550.1 cds chromosome:TAIR10:1:24828537:24829589:1 gene:AT1G66550 gene_biotype:protein_coding transcript_biotype:protein_coding gene_symbol:WRKY67 description:Probable WRKY transcription factor 67 [Source:UniProtKB/Swiss-Prot;Acc:Q93WV7]</span><br><span class="line">ATGGTTTCCAACATTGATCACAAGGCTATGGAAGCACTCCTCCGTGGCCAAGGATGCGCT</span><br><span class="line">AACAACCTCAAGATTCTCCTTGAAAACGGCGAAATAAGCTCAGTTTCAACAGAACCACTC</span><br><span class="line">ATCCACACCATTCTCGATTCTTTCTCACTTGCTCTGTCTTTTATGGATTCTCCTAATCAT</span><br><span class="line">CCACCATACCATGAATCCTCTTCTCATAACATGGCAAGTCATATGTCCCGGAGATCATCT</span><br><span class="line">AAGCAAGTACAACATCGCAGAAAACTTTGTGTAGCAGAAGGTTTAGTGAATTACAATCAC</span><br><span class="line">GATTCCCGGACTATGTGCCCCAATGATGGCTTCACCTGGAGGAAATATGGACAAAAAACC</span><br><span class="line">ATTAAAGCCTCAGCGCACAAAAGGTGTTACTATCGGTGTACCTATGCAAAAGACCAAAAC</span><br><span class="line">TGCAATGCTACAAAGCGGGTGCAGAAGATCAAAGACAACCCTCCAGTGTACAGAACCACT</span><br><span class="line">TACTTGGGAAAACATGTGTGTAAAGCTTTTGCAGTTCATGATGATACATATAGTTCCACG</span><br><span class="line">ATGATTCGATTCGACCAAGTTGTTCCTGAACCGATTATGCCGCAGCTCACAACAATTGAC</span><br><span class="line">CACCAAGTAATTACCGTGGAGGAAAACTCCGCAGAACATATCATGAACCAAGAATGTGAT</span><br><span class="line">ATTAATGATTATTTGGTGGATGATGACCCATTTTGGGCTAGTCAATTTCCCCCGTTTCCA</span><br><span class="line">TCGAGTGACACAATGTTCTTGGAAAACATTTCTGCTTTTGATTAG</span><br><span class="line">&gt;AT4G39410.1 cds chromosome:TAIR10:4:18332606:18334893:-1 gene:AT4G39410 gene_biotype:protein_coding transcript_biotype:protein_coding gene_symbol:WRKY13 description:WRKY13 [Source:UniProtKB/TrEMBL;Acc:A0A178UV80]</span><br><span class="line">ATGGGTGCGATAAACCAAGGAATAAGCTTGTTTGATGAATCACAAACCGTCATAAACCCT</span><br><span class="line">ATTAATACCAACCATCTAGGTTTCTTCTTCTCTTTCCCTAGTCACAGCACCTTATCTTCA</span><br><span class="line">TCATCTTCGTCGTCTTCGTCTTCTCCTTCTTCTCTTGTGTCTCCATTTCTTGGTCATAAC</span><br><span class="line">TCCCTAAACTCCTTCCTTCATAATAACCCGTCTTCATTCATAAGTCATCCTCAAGATTCC</span><br><span class="line">ATCAATCTCATGACCAATCTCCCCGAAACCCTAATCTCGTCTTTGTCCTCATCAAAGCAA</span><br><span class="line">AGGGACGATCATGATGGTTTTCTTAATCTCGATCATCATCGTCTTACCGGTAGTATTTCA</span><br><span class="line">TCCCAAAGACCCCTGTCAAATCCATGGGCATGGAGTTGTCAAGCGGGATACGGAAGCAGC</span><br><span class="line">CAGAAAAACAACCATGGAAGCGAGATTGATGTTGATGATAATGATGATGAGGTTGGCGAT</span><br><span class="line">GGTGGTGGCATTAATGATGATGATAATGGTCGTCATCATCATCATGATACTCCCAGTCGT</span><br><span class="line">CATGATAAACATAACACAGCGTCATTAGGCGTAGTTTCTTCTCTGAAGATGAAGAAGCTT</span><br><span class="line">AAGACAAGAAGAAAAGTGAGGGAACCTCGGTTTTGCTTTAAGACACTTAGCGAGGTTGAT</span><br><span class="line">GTCTTAGATGATGGATATAGATGGAGAAAGTATGGCCAGAAAGTTGTCAAAAACACCCAA</span><br><span class="line">CATCCCAGGAGCTATTACAGATGCACACAAGACAAGTGTAGAGTGAAGAAGAGAGTGGAG</span><br><span class="line">AGATTAGCAGATGACCCAAGAATGGTAATCACTACTTACGAAGGAAGACACCTTCACTCT</span><br><span class="line">CCTTCTAATCATCTCGACGACGACTCTCTCTCCACCTCTCACCTGCACCCTCCTCTCTCC</span><br><span class="line">AACTTCTTCTGGTGA</span><br><span class="line">&gt;AT4G18170.1 cds chromosome:TAIR10:4:10061214:10062893:1 gene:AT4G18170 gene_biotype:protein_coding transcript_biotype:protein_coding gene_symbol:WRKY28 description:WRKY28 [Source:UniProtKB/TrEMBL;Acc:A0A178V3M3]</span><br><span class="line">ATGTCTAATGAAACCAGAGATCTCTACAACTACCAATACCCTTCATCGTTTTCGTTGCAC</span><br><span class="line">GAAATGATGAATCTGCCTACTTCAAATCCATCTTCTTATGGAAACCTCCCATCACAAAAC</span><br><span class="line">GGTTTTAATCCATCTACTTATTCCTTCACCGATTGTCTCCAAAGTTCTCCAGCAGCGTAT</span><br><span class="line">GAATCTCTACTTCAGAAAACTTTTGGTCTTTCTCCCTCTTCCTCAGAGGTTTTCAATTCT</span><br><span class="line">TCGATCGATCAAGAACCGAACCGTGATGTTACTAATGACGTAATCAATGGTGGTGCATGC</span><br><span class="line">AACGAGACTGAAACTAGGGTTTCTCCTTCTAATTCTTCCTCTAGTGAGGCTGATCACCCC</span><br><span class="line">GGTGAAGATTCCGGTAAGAGCCGGAGGAAACGAGAGTTAGTCGGTGAAGAAGATCAAATT</span><br><span class="line">TCCAAAAAAGTTGGGAAAACGAAAAAGACTGAGGTGAAGAAACAAAGAGAGCCACGAGTC</span><br><span class="line">TCGTTTATGACTAAAAGTGAAGTTGATCATCTTGAAGATGGTTATAGATGGAGAAAATAC</span><br><span class="line">GGCCAAAAGGCTGTAAAAAATAGCCCTTATCCAAGGAGTTACTATAGATGTACAACACAA</span><br><span class="line">AAGTGCAACGTGAAGAAACGAGTGGAGAGATCGTTCCAAGATCCAACGGTTGTGATTACA</span><br><span class="line">ACTTACGAGGGTCAACACAACCACCCGATTCCGACTAATCTTCGAGGAAGTTCTGCCGCG</span><br><span class="line">GCTGCTATGTTCTCCGCAGACCTCATGACTCCAAGAAGCTTTGCACATGATATGTTTAGG</span><br><span class="line">ACGGCAGCTTATACTAACGGCGGTTCTGTGGCGGCGGCTTTGGATTATGGATATGGACAA</span><br><span class="line">AGTGGTTATGGTAGTGTGAATTCAAACCCTAGTTCTCACCAAGTGTATCATCAAGGGGGT</span><br><span class="line">GAGTATGAGCTCTTGAGGGAGATTTTTCCTTCAATTTTCTTTAAGCAAGAGCCTTGA</span><br><span class="line">&gt;AT5G45050.1 cds chromosome:TAIR10:5:18176914:18181973:-1 gene:AT5G45050 gene_biotype:protein_coding transcript_biotype:protein_coding gene_symbol:RRS1B description:Probable WRKY transcription factor 16 [Source:UniProtKB/Swiss-Prot;Acc:Q9FL92]</span><br><span class="line">ATGACCGAGAGTGAGCAAATCGTCTACATCAGCTGCATAGAGGAGGTACGATACTCCTTC</span><br><span class="line">GTCAGCCACCTCTCCAAAGCTCTCCAGCGAAAAGGTGTAAACGATGTCTTCATCGATAGC</span><br><span class="line">GATGATTCGCTTTCCAACGAGTCTCAATCAATGGTCGAGAGAGCTAGGGTTTCTGTTATG</span><br><span class="line">ATTTTACCAGGAAACCGTACGGTATCTCTTGACAAGCTCGTGAAGGTTCTCGATTGCCAG</span><br><span class="line">AAGAACAAAGATCAAGTGGTGGTTCCGGTGTTGTACGGTGTCAGATCATCAGAGACCGAA</span><br><span class="line">TGGCTTAGCGCGCTGGATTCGAAAGGATTCTCATCAGTACACCATTCCAGGAAAGAATGT</span><br><span class="line">AGTGACTCCCAGCTTGTAAAAGAGACTGTTAGAGATGTGTATGAGAAGCTCTTTTATATG</span><br><span class="line">GAACGAATTGGAATATATTCGAAGCTGCTGGAGATTGAGAAAATGATTAACAAGCAACCG</span><br><span class="line">TTGGACATCCGTTGTGTTGGAATTTGGGGTATGCCTGGCATAGGCAAGACTACACTTGCT</span><br><span class="line">AAAGCAGTCTTTGACCAAATGTCTGGTGAGTTTGATGCTCATTGCTTTATTGAAGACTAC</span><br><span class="line">ACCAAAGCTATTCAAGAGAAGGGTGTTTATTGTTTGCTGGAGGAACAGTTTTTGAAAGAA</span><br><span class="line">AATGCTGGTGCTAGTGGTACCGTTACGAAATTGAGCTTGCTTAGGGATAGATTAAACAAT</span><br><span class="line">AAGAGGGTTCTTGTTGTTCTTGATGATGTCCGCAGTCCTCTGGTTGTGGAGTCTTTTCTT</span><br><span class="line">GGAGGGTTTGACTGGTTTGGTCCCAAAAGTCTAATCATCATAACCTCCAAAGATAAATCG</span><br><span class="line">GTGTTTCGCCTTTGTCGAGTCAATCAAATATACGAGGTTCAGGGTTTAAATGAGAAAGAG</span><br><span class="line">GCTCTTCAACTCTTCTCTTTGTGTGCGTCTATAGACGATATGGCAGAGCAGAATCTCCAC</span><br><span class="line">GAGGTGTCAATGAAAGTTATTAAATATGCTAATGGCCATCCATTAGCTCTCAATCTCTAT</span><br><span class="line">GGCAGAGAACTGATGGGGAAGAAAAGACCACCAGAAATGGAGATAGCATTCCTCAAACTC</span><br><span class="line">AAGGAATGTCCTCCAGCTATTTTTGTTGATGCAATCAAGAGCTCGTATGACACACTCAAT</span><br><span class="line">GACAGGGAAAAAAACATTTTTTTGGACATAGCTTGTTTCTTCCAGGGAGAAAATGTTGAC</span><br><span class="line">TACGTGATGCAACTGCTTGAGGGTTGTGGTTTCTTTCCACATGTTGGAATTGATGTTCTT</span><br><span class="line">GTGGAGAAGAGTCTGGTGACTATTTCAGAAAACCGAGTGCGGATGCATAACTTGATCCAA</span><br><span class="line">GATGTTGGCCGACAAATAATAAATAGAGAAACAAGACAGACTAAGAGGCGCAGCAGACTG</span><br><span class="line">TGGGAACCTTGCAGCATCAAATATTTATTAGAAGATAAGGAACAAAACGAAAATGAAGAA</span><br><span class="line">CAAAAAACAACTTTTGAACGTGCTCAGGTCCCTGAAGAGATCGAAGGCATGTTTCTGGAC</span><br><span class="line">ACATCAAACTTAAGTTTTGATATTAAGCATGTTGCCTTTGATAATATGTTGAACCTTAGA</span><br><span class="line">TTGTTCAAGATTTACAGTTCCAATCCTGAAGTCCATCATGTAAACAATTTCCTCAAAGGC</span><br><span class="line">TCTCTCAGTTCTCTTCCTAATGTGCTAAGACTCCTGCATTGGGAGAACTATCCTCTGCAG</span><br><span class="line">TTTCTGCCTCAAAATTTTGATCCTATACACCTTGTTGAAATCAACATGCCGTACAGCCAA</span><br><span class="line">CTTAAGAAACTTTGGGGTGGAACCAAGGACCTGGAGATGTTGAAGACAATCAGGCTTTGT</span><br><span class="line">CATTCCCAACAACTAGTTGATATTGACGATCTTTTAAAAGCTCAAAATCTTGAGGTAGTT</span><br><span class="line">GATCTCCAAGGCTGTACAAGACTGCAGAGTTTCCCAGCCACCGGTCAATTGCTACATTTA</span><br><span class="line">CGAGTTGTAAATCTCTCAGGTTGCACAGAGATCAAAAGTTTCCCAGAAATTCCCCCAAAT</span><br><span class="line">ATTGAGACACTGAATCTACAGGGGACTGGTATAATAGAATTACCACTTTCCATTGTTAAG</span><br><span class="line">CCAAACTACAGAGAGCTTTTGAATCTTCTAGCTGAAATCCCGGGTCTTTCAGGTGTCTCA</span><br><span class="line">AACCTTGAGCAAAGTGATCTCAAACCTTTAACAAGCCTGATGAAAATTAGCACATCTTAC</span><br><span class="line">CAAAATCCTGGCAAGCTTAGTTGCTTGGAGCTGAATGATTGTTCTCGTTTGCGAAGTCTG</span><br><span class="line">CCAAACATGGTTAATTTAGAACTTCTCAAAGCCCTTGATCTTTCTGGTTGCTCAGAGCTC</span><br><span class="line">GAGACTATCCAGGGTTTCCCACGGAACCTGAAAGAGTTATATCTTGTTGGCACTGCAGTA</span><br><span class="line">AGACAAGTGCCACAACTTCCTCAAAGTCTAGAATTCTTTAATGCCCATGGTTGTGTCTCT</span><br><span class="line">CTCAAATCAATTCGTTTGGACTTCAAGAAGCTTCCTGTGCATTACACATTTAGTAATTGT</span><br><span class="line">TTCGATCTATCTCCACAAGTGGTCAACGATTTTTTAGTGCAGGCGATGGCTAATGTGATT</span><br><span class="line">GCAAAACACATACCAAGAGAGCGTCATGTCACAGGCTTTTCTCAAAAGACTGTGCAGCGT</span><br><span class="line">TCGAGTCGTGACAGTCAGCAGGAACTCAACAAAACTTTGGCTTTCAGCTTCTGTGCGCCC</span><br><span class="line">TCACATGCGAATCAAAATTCCAAACTTGATCTGCAACCAGGATCTTCTTCAATGACACGA</span><br><span class="line">CTAGATCCTTCTTGGAGGAACACACTTGTGGGCTTTGCTATGCTGGTGCAAGTCGCATTT</span><br><span class="line">TCCGAGGGTTACTGTGATGATACTGATTTTGGCATTAGTTGTGTTTGCAAATGGAAAAAC</span><br><span class="line">AAGGAAGGCCACTCTCATAGGAGAGAAATAAATTTGCATTGTTGGGCTTTAGGGAAAGCT</span><br><span class="line">GTTGAAAGGGATCATACGTTTGTCTTCTTTGATGTCAACATGCGTCCAGATACCGATGAA</span><br><span class="line">GGAAATGACCCCGATATCTGGGCTGATTTAGTTGTTTTTGAGTTCTTTCCTGTCAATAAA</span><br><span class="line">CAGAGAAAGCCTCTAAATGATAGTTGCACAGTGACAAGATGTGGAGTCCGTTTAATAACT</span><br><span class="line">GCTGTAAACTGCAATACAAGTATCGAGAATATATCACCAGTTTTGTCCTTGGATCCGATG</span><br><span class="line">GAGGTTTCTGGTAATGAAGATGAAGAAGTATTGAGAGTCAGATATGCTGGTTTACAGGAG</span><br><span class="line">ATATATAAAGCTTTGTTTCTTTACATAGCGGGTTTGTTCAATGACGAGGATGTTGGTTTG</span><br><span class="line">GTAGCACCACTTATTGCTAACATTATTGACATGGACGTTAGTTATGGGCTCAAGGTCTTA</span><br><span class="line">GCCTATAGGTCTCTCATACGTGTATCTTCCAATGGGGAAATAGTGATGCACTATTTGCTA</span><br><span class="line">CGACAAATGGGTAAAGAAATCCTCCATACAGAATCAAAGAAGACTGACAAATTAGTCGAC</span><br><span class="line">AATATTCAGAGTTCCATGATCGCAACAAAGGAAATCGAGATCACTCGTTCAAAGAGTCGC</span><br><span class="line">CGAAAGAACAACAAGGAAAAGAGAGTGGTTTGCGTAGTGGATCGAGGCAGCCGGTCCAGT</span><br><span class="line">GACCTATGGGTTTGGCGAAAGTATGGTCAAAAACCCATCAAAAGTTCTCCTTATCCAAGG</span><br><span class="line">AGTTACTATAGATGTGCCAGCTCGAAAGGTTGTTTTGCTAGGAAACAAGTCGAACGTAGC</span><br><span class="line">CGCACTGATCCAAATGTTTCAGTAATTACTTACATCTCTGAGCATAACCATCCATTCCCC</span><br><span class="line">ACTCTACGCAATACTCTTGCCGGCTCCACTCGTTCCTCTTCCTCCAAATGCTCAGATGTA</span><br><span class="line">ACTACTTCTGCCTCATCGACAGTCTCCCAAGACAAAGAAGGACCGGATAAATCCCATTTG</span><br><span class="line">CCTTCCTCCCCTGCTTCTCCTCCTTATGCGGCCATGGTGGTTAAGGAGGAGGACATGGAG</span><br><span class="line">CAATGGGACAATATGGAGTTCGATGTTGACGTTGAAGAAGATACTTTCATACCCGAATTA</span><br><span class="line">TTTCCAGAGGATACCTTCGCTGATATGGACAAGCTTGAGGAAAATTCTCAGACTATGTTT</span><br><span class="line">CTCTCTCGCAGAAGCAGCGGAGGCAACATGGAAGCCCAAGGGAAGAACTCTAGTGATGAT</span><br><span class="line">AGGGAGGTCAATTTACCTAGTAAAATTCTGAATAGATAG</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fastq文件 ：<br>详细介绍可以观看：<a href="https://www.omicsclass.com/course/28">https://www.omicsclass.com/course/28</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@A00808:122:HM2JCDSXX:1:1101:3025:1000 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">AATTATTCCAAGTGATCATTTAATTTAACAGTACGTTATTACAGTTTTTGACAATACACCAGGAGGGGCAGAAGCAGCACTCCATTTATGCGCCGAATTCTCGTACAGACACACACACACACACAGATTCACACAGTCAATTCAGTCCTT</span><br><span class="line">+</span><br><span class="line">FFFFFFFFFFFF:FFFF:FFFFFFFFFFFFFFFFFFF,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:4399:1000 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">CTTTGCTATAAACTAAGTCACCTTCTACAGCCTGCGAAATGCCATATTTTTCAACTCTGGCACTGGCAGCATGGTTCCAGAGGTAACTTTGGTAACTATGAACGTACATCATTCGTAATGTTCTTGGTATACTCTTTAATGCTTGCAGAT</span><br><span class="line">+</span><br><span class="line">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:F,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:8522:1000 1:N:0:TCGGAAGT+ACAAGGCA</span><br><span class="line">NACTTTTCAGATTTCAACTTGAGAGATGGACCATCAAGAGCCTTTTTCATGTCACGTTTTTGAGCCATACAATGATACAGACGAAAGAAAACAAGCCAAACAACTCATCCAACCGACCGCGAACAGTAGACACAATTACACAAACACATG</span><br><span class="line">+</span><br><span class="line">#FFF,:FFF:,:FFF:F:FF:FFFFFF:FFF,F:FFF,F,:FF,:FFFF:FFFFF:FF,FF::,,FFFFFFFF:F:FFF,,,FFFFFF,FFF,:,:F::FFFFFFFFFFFFFF,FFFFFF:FFF,,F:,,F:F,:,FFF:,,FF:,FFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:13205:1000 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">NTTCGACGAGGAGGCCGCCTGCGCGCGCGACGCCGCCGGGGAGGCCCTCGCGGCCTTCGAGTCGCTGCTCGCGCGCCTCCCCCCGCCCGACGCCGACTCGCGCCGCCGATCCATGGGGCTCAAGTTGGAGCAGCACAAAGCCGAGCTCAA</span><br><span class="line">+</span><br><span class="line">#FFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFF,F:FFFF,FFFFF,F,FFFFFF:FF:FF:FF:,:,,F,FFFFF,F,:F:FFF:,F,FFFFF,F,:,,,FFF::,:FFFF,FF:,:,:,,FFF,F,FF,,FFFFF,FFFF,FFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:3902:1016 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">GTCGTCGTCACCGAATGTTGTCTTCTTTCCTGCACTAGGTGTACCAGCGCTCTGCTTGAACGGTGTACCCCGTCCACCACGGCCCCTGTCACCCCTACCAAAGCCTCTACCACGTCCACGGTCACCGCGCCCACGGCTACCATCACCACG</span><br><span class="line">+</span><br><span class="line">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:20518:1016 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">NGCTGGAGAACTAAGTGTCGATCTTCACCTTCACCAACAGATTCATGAACAAACCTAGCAGCGACACAAAAGCAAGACATTAGTAGTTGCAAATATTACTCTATCCAGTTAAGTTAGTATTTGAGAAGAGGGTAGGTGAAGCAGGTCGAA</span><br><span class="line">+</span><br><span class="line">#FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,FFFFFFFF:F,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:23158:1016 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">NTCCCTGGACTCTGGGGCACTTTAGGGCTAGGAACACTTGTCAAGCGACTCTGAGGCACAGTATCAGACATGGACTTCGAGAAGGCTTGTGCAAGCTCCAATGCAGATGCTCCTTTCCCAAAACGAGGTGCAACAACCTCAGGCTTTGGT</span><br><span class="line">+</span><br><span class="line">#FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:1597:1031 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">CGCCGCCGCACTCTGCAACCGCGCCGCGGGGAGGGAGGGAAGGACGAAGGAGGAAGGAGATGGAGCGGGTCGGCGGCGGGGAGAAGCAGCTGGAGGACTGCACCGTGTCCAATGCTCTCGGCACCTGGTTCTTCTCAGTTGCTGGTGCTC</span><br><span class="line">+</span><br><span class="line">F:FFFFFFFFFFFFFFFFFFFFFFFFFF,FF:FFF:FFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,FFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:3351:1031 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">CCCCCTTGAACTATCCGTAAATACCACCATTCCACCAAACTCCCCTCTGTCTTCTACGACAAATAATCTTTTCAACCCAGTAACTTATAATTAATTACAGAGAGATTAGCAAACATATAATGGTAAGAATCAGTTGTCGTAGGTGCGGCA</span><br><span class="line">+</span><br><span class="line">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFF:FF,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:5466:1031 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">CTCGCAGTGCTTGGTGTACTTGGCCGGGTCCAGCAGGGCGTCCAGCTCCGACGGGCTGCTCGGCTTCACCTTGATCATCCACCCGTCCTCGTACGGGCTTGAGTTAATCAGGCCGGGTGTCTCAGAGAGCTTGTCGTTAACCTCGACGAC</span><br><span class="line">+</span><br><span class="line">:FF:FF:F,FFFFF,FFFF:::FFF,F::F:F:,F,,,FFF:F::FFFF:FFF:F,:::FF:F,:FFFFFFFFFF,FFFFFFF::FFFF:FFFFFFFF:,FFFFFFFF,F,FF,F,FFF,:F,FFF,FFFF,FFFFF,F:,FFFFFFFFF</span><br><span class="line">@A00808:122:HM2JCDSXX:1:1101:6714:1031 1:N:0:TCGGAAGT+ACAAGGCT</span><br><span class="line">CGACGAGATCGGCCGCTCCGAATCCGATCCGCGCACGTGGTCTCGCCGGCGGGGTCAGGTTGGTTCGCGGGAGCCGCCGCCGCCGCCGACGACGACGACGATGGCCATGGAGACGCCGCCGCCGTTCCAGGAGTCCGCCCACTGCGACGT</span><br><span class="line">+</span><br><span class="line">FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;任务1 答案：&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">from Bio import SeqIO</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.chdir(&quot;D:\\python_script&quot;)</span><br><span class="line"></span><br><span class="line">idlist=&#123;&#125;  #字典用于存储ID列表</span><br><span class="line">f = open(&quot;idlist.txt&quot;, &quot;r&quot;)  #打开ID列表文件</span><br><span class="line">for line in f:</span><br><span class="line">    line=line.strip()</span><br><span class="line">    idlist[line]=1</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f_out = open(&quot;get.fa&quot;, &quot;w&quot;)</span><br><span class="line">for rec in SeqIO.parse(&quot;test.fa&quot;, &quot;fasta&quot;):</span><br><span class="line">    if rec.id in idlist:  #判断ID是否存在与ID列表字典中</span><br><span class="line">        SeqIO.write(rec,f_out,&quot;fasta&quot;)   #如果存在写出该序列</span><br><span class="line">        </span><br><span class="line">f_out.close()</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;任务2 答案：&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">from Bio import SeqIO</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">os.chdir(&quot;D:\\python_script&quot;)</span><br><span class="line"></span><br><span class="line">idlist=&#123;&#125;  #字典用于存储ID列表以及位置</span><br><span class="line">f = open(&quot;id_pos.txt&quot;, &quot;r&quot;)  #打开ID列表文件</span><br><span class="line">for line in f:</span><br><span class="line">    line=line.strip()</span><br><span class="line">    tmp=re.split(r&quot;\t&quot;,line)</span><br><span class="line">    idlist[tmp[0]]=[int(tmp[1]),int(tmp[2])]</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f_out = open(&quot;get_pos.fa&quot;, &quot;w&quot;)</span><br><span class="line">for rec in SeqIO.parse(&quot;test.fa&quot;, &quot;fasta&quot;):</span><br><span class="line">    if rec.id in idlist:  #判断ID是否存在与ID列表字典中</span><br><span class="line">        start=idlist[rec.id][0]  #取得对应ID要截取的起始位置</span><br><span class="line">        end=idlist[rec.id][1]   #取得对应ID要截取的结束位置</span><br><span class="line">        rec_new=SeqRecord(rec.seq[start-1:end],id=rec.id,description=rec.description) #注意生物数据一般是从1作为索引，编程语言一般是从0开始所以要减一</span><br><span class="line">        SeqIO.write(rec_new,f_out,&quot;fasta&quot;)   #写出截取好的序列</span><br><span class="line">        </span><br><span class="line">f_out.close()</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;任务3 答案：&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">from Bio import SeqIO</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.chdir(&quot;D:\\python_script&quot;)</span><br><span class="line">output_handle = open(&quot;fq2fa.fa&quot;, &quot;w&quot;)</span><br><span class="line">for rec in SeqIO.parse(&quot;test.fq&quot;, &quot;fastq&quot;):</span><br><span class="line">    SeqIO.write(rec, output_handle, &quot;fasta&quot;)</span><br><span class="line"></span><br><span class="line">output_handle.close()</span><br></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;任务4 答案：&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Bio.Seq import Seq</span><br><span class="line">from Bio.SeqRecord import SeqRecord</span><br><span class="line">from Bio import SeqIO</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.chdir(&quot;D:\\python_script&quot;)</span><br><span class="line">output_handle = open(&quot;trimed.fq&quot;, &quot;w&quot;)</span><br><span class="line">for rec in SeqIO.parse(&quot;test.fq&quot;, &quot;fastq&quot;):</span><br><span class="line">    rec_new=rec[5:]</span><br><span class="line">    SeqIO.write(rec_new, output_handle, &quot;fastq&quot;)</span><br><span class="line">output_handle.close()</span><br></pre></td></tr></table></figure>

<h2 id="6-Python-中数据统计分析包numpy-与-pandas"><a href="#6-Python-中数据统计分析包numpy-与-pandas" class="headerlink" title="6  Python 中数据统计分析包numpy 与 pandas"></a>6  Python 中数据统计分析包numpy 与 pandas</h2><h3 id="6-1-数据统计分析包介绍"><a href="#6-1-数据统计分析包介绍" class="headerlink" title="6.1 数据统计分析包介绍"></a>6.1 数据统计分析包介绍</h3><ul>
<li><p><strong>NumPy：N维数组矩阵容器；</strong> 基础的数学计算模块。</p>
</li>
<li><p><strong>Pandas：表格容器；</strong> 提供了一套名为DataFrame的数据结构，适合统计分析表格类数据。</p>
</li>
<li><p><strong>SciPy：科学计算函数库；</strong> 基于Numpy，提供方法(函数库)直接计算结果；封装了一些高阶抽象的物理模型。比方说做个傅立叶变换，做个滤波器等等。</p>
</li>
</ul>
<p>&#x3D;&#x3D;非数学研究，建议直接入手Numpy，pandas。目的，是方便我们处理表格类的生物数据。&#x3D;&#x3D;</p>
<h3 id="6-2-Numpy包学习"><a href="#6-2-Numpy包学习" class="headerlink" title="6.2 Numpy包学习"></a>6.2 Numpy包学习</h3><p>Numpy：<br>用来存储和处理大型矩阵，本身是由C语言开发，和列表（list）的使用很像，但是计算速度要比列表快很多。</p>
<ul>
<li>官方网站：<a href="https://numpy.org/">https://numpy.org/</a></li>
<li>中文文档：<a href="http://liao.cpython.org/parttwo/">http://liao.cpython.org/parttwo/</a></li>
</ul>
<h4 id="6-2-1-安装"><a href="#6-2-1-安装" class="headerlink" title="6.2.1 安装"></a>6.2.1 安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 pip</span><br><span class="line">pip install numpy -i  https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">#导入：</span><br><span class="line">import numpy as np</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-矩阵-数组创建函数"><a href="#6-2-2-矩阵-数组创建函数" class="headerlink" title="6.2.2 矩阵&#x2F;数组创建函数"></a>6.2.2 矩阵&#x2F;数组创建函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>np.array()</td>
<td>创建数组</td>
</tr>
<tr>
<td>np.zeros()</td>
<td>创建数据全为0</td>
</tr>
<tr>
<td>np.ones()</td>
<td>创建数据全为1</td>
</tr>
<tr>
<td>np.empty()</td>
<td>创建数据接近0</td>
</tr>
<tr>
<td>np.arange()</td>
<td>按指定范围创建数据</td>
</tr>
<tr>
<td>np.linspace()</td>
<td>创建线段</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np #为了方便使用numpy 采用np简写</span><br><span class="line">#列表转化为矩阵</span><br><span class="line">a = np.array([2,23,4])</span><br><span class="line">a = np.array([[11, 12, 13, 14, 15],</span><br><span class="line">              [16, 17, 18, 19, 20],</span><br><span class="line">              [21, 22, 23, 24, 25],</span><br><span class="line">              [26, 27, 28 ,29, 30],</span><br><span class="line">              [31, 32, 33, 34, 35]])</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">#指定数据类型</span><br><span class="line">a = np.array([2,23,4],dtype=np.int)</span><br><span class="line">print(a.dtype)</span><br><span class="line"></span><br><span class="line">a = np.arange(10,20,2) # 10-19 的数据，2步长</span><br><span class="line">a = np.linspace(1,10,20)    # 开始端1，结束端10，且分割成20个数据，生成线段</span><br><span class="line"></span><br><span class="line">a = np.zeros((3,4)) # 数据全为0，3行4列</span><br><span class="line">a = np.ones((3,4),dtype = np.int)   # 数据为1，3行4列</span><br><span class="line">a = np.empty((3,4)) # 数据为empty，3行4列</span><br></pre></td></tr></table></figure>

<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>NumPy支持的数值类型</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>np.bool</td>
<td>True和Flase</td>
</tr>
<tr>
<td>np.int</td>
<td>支持int的32或64位</td>
</tr>
<tr>
<td>np.int8</td>
<td>8位的整形(-128~127)</td>
</tr>
<tr>
<td>np.int16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>np.int32</td>
<td>-2 ** 31 ~ 2 ** 31 - 1</td>
</tr>
<tr>
<td>np.int64</td>
<td>-2 ** 63 ~ 2 ** 63 - 1</td>
</tr>
<tr>
<td>np.uint8</td>
<td>8位的整形(0~255)</td>
</tr>
<tr>
<td>np.uint16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>np.uint32</td>
<td>0 ~ 2 ** 32 - 1</td>
</tr>
<tr>
<td>np.uint64</td>
<td>0 ~ 2 ** 64 - 1</td>
</tr>
<tr>
<td>np.float16</td>
<td>1位符号位，5位指数位，10位</td>
</tr>
<tr>
<td>np.float32</td>
<td>1位符号位，8位指数位，23位</td>
</tr>
<tr>
<td>np.float64、np.float</td>
<td>1位符号位，11位指数位，52位</td>
</tr>
</tbody></table>
<h4 id="6-2-3-特定分布随机数创建矩阵函数"><a href="#6-2-3-特定分布随机数创建矩阵函数" class="headerlink" title="6.2.3 特定分布随机数创建矩阵函数"></a>6.2.3 特定分布随机数创建矩阵函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.random.rand(d0,d1,…,dn)</td>
<td>根据d0-dn(维度)创建随机数数组，[0,1)，均匀分布</td>
</tr>
<tr>
<td>np.random.randn(d0,d1,…,dn)</td>
<td>根据d0-dn(维度)创建随机数数组，标准正态分布</td>
</tr>
<tr>
<td>np.random.randint(low[,high,shape])</td>
<td>根据shape创建随机整数或整数数组，范围是[low,high)</td>
</tr>
<tr>
<td>np.random.normal(loc,scale,size)</td>
<td>产生具有正态分布的数组，loc为均值，scale标准差，size为形状</td>
</tr>
<tr>
<td>np.random.permutation(a)</td>
<td>根据数组a的第1轴产生一个新的乱序数组，不改变数组a</td>
</tr>
<tr>
<td>np.random.choice(a[,size,replace,p])</td>
<td>从一维数组a中以概率p抽取元素，形成size形状新数组replace表示是否可能重用元素，默认为False</td>
</tr>
<tr>
<td>np.random.uniform(low,high,size)</td>
<td>产生具有均匀分布的数组，low起始值，high结束值，size为形状</td>
</tr>
<tr>
<td>np.random.poisson(lam,size)</td>
<td>产生具有泊松分布的数组，lam为随机事件发生率，size为形状</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np #为了方便使用numpy 采用np简写</span><br><span class="line"></span><br><span class="line">#产生均匀分布的数据，2x3x4 三维数据</span><br><span class="line">np.random.rand(2,3,4) </span><br><span class="line"></span><br><span class="line"># 产生20个均值为2、标准差为0.1满足正态分布的随机数序列</span><br><span class="line">a = np.random.normal(2, 0.1, 20)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="6-2-4-矩阵-数组对象相关方法与属性"><a href="#6-2-4-矩阵-数组对象相关方法与属性" class="headerlink" title="6.2.4 矩阵&#x2F;数组对象相关方法与属性"></a>6.2.4 矩阵&#x2F;数组对象相关方法与属性</h4><h5 id="reshape-和resize-方法"><a href="#reshape-和resize-方法" class="headerlink" title="reshape()  和resize()方法"></a>reshape()  和resize()方法</h5><ul>
<li>reshape()方法，在reshape方法里以元组、列表给出变化后的形状数据，并不影响原数组会新生成一个多维数组。</li>
<li>resize() 方法，会修改数组本身的shape属性来改变数组的维度，原数组发生改变。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#reshape方法，注意a被修改了</span><br><span class="line">a = np.arange(12)</span><br><span class="line">print(a)</span><br><span class="line">a.reshape((3, 4))  </span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">#resize方法，注意a被修改了</span><br><span class="line">a = np.arange(12)</span><br><span class="line">a.resize([3, 4])</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#通过属性修改维度，注意a被修改了</span><br><span class="line">a = np.arange(12)</span><br><span class="line">print(a)</span><br><span class="line">a.shape = (2, 6)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="数组的一些属性"><a href="#数组的一些属性" class="headerlink" title="数组的一些属性"></a>数组的一些属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Array properties</span><br><span class="line">import numpy as np</span><br><span class="line">a = np.array([[11, 12, 13, 14, 15],</span><br><span class="line">              [16, 17, 18, 19, 20],</span><br><span class="line">              [21, 22, 23, 24, 25],</span><br><span class="line">              [26, 27, 28 ,29, 30],</span><br><span class="line">              [31, 32, 33, 34, 35]])</span><br><span class="line"></span><br><span class="line">print(type(a)) # &gt;&gt;&gt;&lt;class &#x27;numpy.ndarray&#x27;&gt;    正如你在上面的代码中看到的，NumPy数组实际上被称为：多维数组，ndarray。</span><br><span class="line">print(a.dtype) # &gt;&gt;&gt;int32    数据类型</span><br><span class="line">print(a.size) # &gt;&gt;&gt;25    数据总个数</span><br><span class="line">print(a.shape) # &gt;&gt;&gt;(5, 5)   数组的形状是它有多少行和列，上面的数组有5行和5列，所以它的形状是(5，5)。</span><br><span class="line">print(a.ndim) # &gt;&gt;&gt;2   数组的维数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="矩阵数据支持索引，切片-类似列表"><a href="#矩阵数据支持索引，切片-类似列表" class="headerlink" title="矩阵数据支持索引，切片 类似列表"></a>矩阵数据支持索引，切片 类似列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(24)</span><br><span class="line">print (a[3])</span><br><span class="line"></span><br><span class="line">#二维数组索引</span><br><span class="line">#对于2D数组：行的切片，列的切片。</span><br><span class="line">a = np.arange(12)</span><br><span class="line">a = a.reshape((3, 4))</span><br><span class="line">print(a[0, 1:4])</span><br><span class="line">print(a[1:4, 0])</span><br><span class="line">print(a[::2,::2])</span><br><span class="line"></span><br><span class="line">#三维数组索引</span><br><span class="line">a = np.arange(24)</span><br><span class="line">b = a.reshape((2, 3, 4))</span><br><span class="line">print (b[1,1:2,1:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="数组支持布尔筛选"><a href="#数组支持布尔筛选" class="headerlink" title="数组支持布尔筛选"></a>数组支持布尔筛选</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0, 100, 10)</span><br><span class="line">b = a[:5]</span><br><span class="line">c = a[a &gt;= 50]</span><br><span class="line">print(b) </span><br><span class="line">print(c) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Where 函数筛选</span><br><span class="line">a = np.arange(0, 100, 10)</span><br><span class="line">b = np.where(a &lt; 50) </span><br><span class="line">c = np.where(a &gt;= 50)[0]</span><br><span class="line">print(b) </span><br><span class="line">print(c) </span><br></pre></td></tr></table></figure>



<h4 id="6-2-5-NumPy的数学统计函数"><a href="#6-2-5-NumPy的数学统计函数" class="headerlink" title="6.2.5 NumPy的数学统计函数"></a>6.2.5 NumPy的数学统计函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.abs() np.fabs()</td>
<td>计算数组各元素的绝对值</td>
</tr>
<tr>
<td>np.sqrt()</td>
<td>计算数组各元素的平方根</td>
</tr>
<tr>
<td>np.square()</td>
<td>计算数组各元素的平方</td>
</tr>
<tr>
<td>np.log(x),np.log10(x),np.log2(x)</td>
<td>计算数组各元素的自然对数、10底对数和2底对数</td>
</tr>
<tr>
<td>np.ceil(x),np.floor(x)</td>
<td>计算数组各元素的ceiling值或floor值</td>
</tr>
<tr>
<td>np.rint(x)</td>
<td>计算数组各元素的四舍五入值</td>
</tr>
<tr>
<td>np.modf(x)</td>
<td>将数据各元素的整数和小数部分以两个独立的数组形式返回</td>
</tr>
<tr>
<td>np.cos&#x2F;cosh&#x2F;sin&#x2F;sinh&#x2F;tan&#x2F;tanh</td>
<td>计算数据各元素的普通型和双典型的三角函数</td>
</tr>
<tr>
<td>np.exp(x)</td>
<td>计算数组各元素的指数值</td>
</tr>
<tr>
<td>np.sum(a,axis&#x3D;None)</td>
<td>根据给定axis计算数组a相关元素之和，axis整数或元组</td>
</tr>
<tr>
<td>np.mean(a,axis&#x3D;None)</td>
<td>根据给定axis计算数组a相关元素的期望，axis整数或元组</td>
</tr>
<tr>
<td>np.average(a,axis&#x3D;None,weights&#x3D;None)</td>
<td>根据给定axis计算数组a相关元素的加权平均值</td>
</tr>
<tr>
<td>np.std(a,axis&#x3D;None)</td>
<td>根据给定轴axis计算数组a相关元素的标准差</td>
</tr>
<tr>
<td>np.var(a,axis &#x3D; None)</td>
<td>根据给定轴axis计算数组a相关元素的方差</td>
</tr>
<tr>
<td>np.cov(a,axis &#x3D; None)</td>
<td>计算协方差</td>
</tr>
<tr>
<td>np.corrcoef</td>
<td>计算相关系数，参阅</td>
</tr>
<tr>
<td>np.min(a) max(a)</td>
<td>计算数组a中元素的最小值，最大值</td>
</tr>
<tr>
<td>np.argmin(a) argmax(a)</td>
<td>计算数组a中元素的最小值，最大值的降一维后下标</td>
</tr>
<tr>
<td>np.unravel_index(index,shape)</td>
<td>根据shape将一维下标index转换成多维下标</td>
</tr>
<tr>
<td>np.ptp(a)</td>
<td>计算数组a中元素最大值和最小值的差</td>
</tr>
<tr>
<td>np.median(a)</td>
<td>计算数组a中元素的中位数(中值)</td>
</tr>
</tbody></table>
<p>iris.data测试数据下载：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/iris/">https://archive.ics.uci.edu/ml/machine-learning-databases/iris/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">os.chdir(&quot;D://python_script//&quot;)</span><br><span class="line">a, b = np.loadtxt(&quot;iris.data&quot;,  delimiter=&#x27;,&#x27;, usecols = [0, 1],unpack=True)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(np.average(a))</span><br><span class="line">print(np.mean(a))</span><br><span class="line">print(np.max(a))</span><br><span class="line">print(np.argmax(a))</span><br><span class="line">print(np.min(a))</span><br><span class="line">print(np.argmin(a), a[np.argmin(a)])</span><br><span class="line">print(np.ptp(a))</span><br><span class="line">print(np.std(a))</span><br><span class="line">print(np.median(a))</span><br><span class="line">print(np.sqrt(a), np.square(a))</span><br><span class="line">print(np.rint(a))</span><br><span class="line">print(np.ceil(a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#print(np.column_stack([a, b]))</span><br></pre></td></tr></table></figure>
<p>NumPy的算术运算，类似线性代数计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># Basic Operators</span><br><span class="line">a = np.arange(25)</span><br><span class="line">a = a.reshape((5, 5))</span><br><span class="line"></span><br><span class="line">b = np.array([10, 62, 1, 14, 2, 56, 79, 2, 1, 45,</span><br><span class="line">              4, 92, 5, 55, 63, 43, 35, 6, 53, 24,</span><br><span class="line">              56, 3, 56, 44, 78])</span><br><span class="line">b = b.reshape((5,5))</span><br><span class="line"></span><br><span class="line">print(a + b)</span><br><span class="line">print(a - b)</span><br><span class="line">print(a * b)</span><br><span class="line">print(a / b)</span><br><span class="line">print(a ** 2)</span><br><span class="line">print(a &lt; b) </span><br><span class="line">print(a &gt; b)</span><br></pre></td></tr></table></figure>


<h3 id="6-3-Pandas简介"><a href="#6-3-Pandas简介" class="headerlink" title="6.3 Pandas简介"></a>6.3 Pandas简介</h3><p>基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。最具有统计意味的工具包，某些方面优于R软件。数据结构有一维的Series，二维的DataFrame，三维的Panel。</p>
<ul>
<li>官方网站：<a href="http://pandas.pydata.org/">http://pandas.pydata.org/</a></li>
<li>中文文档：<a href="http://liao.cpython.org/partFive/">http://liao.cpython.org/partFive/</a></li>
</ul>
<h4 id="Pandas数据类型"><a href="#Pandas数据类型" class="headerlink" title="Pandas数据类型"></a>Pandas数据类型</h4><ul>
<li><strong>Series</strong>：一维数组，与Numpy中的一维array类似。二者与Python基本的数据结构List也很相近，其区别是：List中的元素可以是不同的数据类型，而Array和Series中则只允许存储相同的数据类型，这样可以更有效的使用内存，提高运算效率。</li>
<li><strong>DataFrame</strong>：二维的表格型数据结构。很多功能与R中的data.frame类似。可以将DataFrame理解为Series的容器。</li>
<li><strong>Time-Series</strong>：以时间为索引的Series。</li>
<li><strong>Panel</strong>：三维的数组，可以理解为DataFrame的容器。则可以视为excel的多表单sheet。</li>
</ul>
<h4 id="6-3-1-安装"><a href="#6-3-1-安装" class="headerlink" title="6.3.1 安装"></a>6.3.1 安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/  pandas</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-创建Series"><a href="#6-3-2-创建Series" class="headerlink" title="6.3.2 创建Series"></a>6.3.2 创建Series</h4><p>Series构造函数的name参数是给这列数据指定字段名。从结果可以看出t有两个名为’a’的label，值分别为2和7。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">i = [&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]</span><br><span class="line">v = [2, 4, 5, 7]</span><br><span class="line">t = pd.Series(v, index=i, name = &quot;col_name&quot;)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">#数据的访问，支持索引，切片，name取值</span><br><span class="line">print(&quot;t[d]-&gt;&quot;, t[&quot;d&quot;])</span><br><span class="line">print(&#x27;t[0 : 3]-&gt;&#x27;, t[0 : 3])</span><br><span class="line">print(&#x27;t[&quot;a&quot; : &quot;c&quot;]-&gt;&#x27;, t[&quot;c&quot; : &quot;d&quot;])  #注意label唯一才行，不然会报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/group/92990402/noteresource/9B633333F36D413FB1F1BEA6EC8709BC/version/2205?method=get-resource&shareToken=08DB9C16FB6D47AA8EBD104017423D2D&entryId=446741437" alt="image"></p>
<h4 id="Series对象的方法与属性"><a href="#Series对象的方法与属性" class="headerlink" title="Series对象的方法与属性"></a>Series对象的方法与属性</h4><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p>首先看看get方法，可以返回指定的key所对应的value值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">idx =  &quot;hello the cruel world&quot;.split()</span><br><span class="line">val = [1, 21, 13, 104]</span><br><span class="line">t = pd.Series(val, index = idx)</span><br><span class="line"></span><br><span class="line">t.get(&quot;the&quot;)</span><br><span class="line">t.get(&quot;The&quot;, &quot;None&quot;)  #如果key不存在，返回default的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="add、append方法"><a href="#add、append方法" class="headerlink" title="add、append方法"></a>add、append方法</h5><p>add和append方法都能改变series，只不过add类似于加法操作，而append则是连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">idx =  &quot;hello the cruel world&quot;.split()</span><br><span class="line">val1 = [1, 21, 13, 104]</span><br><span class="line"></span><br><span class="line">t = pd.Series(val1, index = idx)</span><br><span class="line"></span><br><span class="line">val2 = [4, 4, 4, 4]</span><br><span class="line">s = pd.Series(val2, index = idx)</span><br><span class="line">t.add(s) </span><br><span class="line">t + 4</span><br><span class="line"></span><br><span class="line">t.append(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-3-3-DataFrame创建"><a href="#6-3-3-DataFrame创建" class="headerlink" title="6.3.3 DataFrame创建"></a>6.3.3 DataFrame创建</h4><p>Pandas的Dataframe是二维的，每一列都是一个Series结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#手动创建</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">df1 = pd.DataFrame(&#123;&#x27;A&#x27;: 1.,</span><br><span class="line">                    &#x27;B&#x27;: pd.date_range(&#x27;20130101&#x27;, periods=4),</span><br><span class="line">                    &#x27;C&#x27;: pd.Series(1, index=list(range(4)), dtype=&#x27;float32&#x27;),</span><br><span class="line">                    &#x27;D&#x27;: np.array([3] * 4, dtype=&#x27;int32&#x27;),</span><br><span class="line">                    &#x27;E&#x27;: [&quot;test&quot;, &quot;train&quot;, &quot;test&quot;, &quot;train&quot;],</span><br><span class="line">                    &#x27;F&#x27;: &#x27;foo&#x27;&#125;,index=list(&quot;abcd&quot;))</span><br><span class="line">#numpy矩阵手动创建</span><br><span class="line">df2 = pd.DataFrame(np.random.randn(10,3), columns = [&quot;ca&quot;, &quot;cb&quot;, &quot;cc&quot;], index =list(&quot;abcdefghij&quot;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="DataFrame对象的属性与方法学习"><a href="#DataFrame对象的属性与方法学习" class="headerlink" title="DataFrame对象的属性与方法学习"></a>DataFrame对象的属性与方法学习</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>columns</td>
<td>columns属性可以获得dataframe有那些列，即dataframe的index</td>
</tr>
<tr>
<td>shape</td>
<td>shape属性是描述dataframe的形状的</td>
</tr>
<tr>
<td>size</td>
<td>dataframe的size属性返回的是dataframe的value的个数</td>
</tr>
<tr>
<td>values</td>
<td>返回当前dataframe的数据和index、columns相对应。</td>
</tr>
<tr>
<td>dtypes</td>
<td>述当前dataframe的里的每列值的数据类型。</td>
</tr>
<tr>
<td>ndim</td>
<td>返回数据框维度</td>
</tr>
<tr>
<td>T</td>
<td>dataframe的T属性，实际是转置的意思。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">df = pd.DataFrame(np.random.randn(10,3), columns = [&quot;ca&quot;, &quot;cb&quot;, &quot;cc&quot;], index =list(&quot;abcdefghij&quot;))</span><br><span class="line">df.columns</span><br><span class="line">df.index</span><br><span class="line">df.shape</span><br><span class="line">df.size</span><br><span class="line">df.values</span><br><span class="line">df.dtypes</span><br><span class="line">df.ndim</span><br><span class="line">df.T</span><br><span class="line"></span><br><span class="line">#方法</span><br><span class="line">df.head()</span><br><span class="line">df.tail(3)</span><br><span class="line">df.to_numpy()</span><br><span class="line">df.describe()  #方法显示数据的快速统计摘要</span><br></pre></td></tr></table></figure>


<h4 id="DataFrame数据访问与筛选"><a href="#DataFrame数据访问与筛选" class="headerlink" title="DataFrame数据访问与筛选"></a>DataFrame数据访问与筛选</h4><p>需要特别注意的是DataFrame和其他表格数据不一样的是，DataFrame是列访问机制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">val = np.arange(10, 40).reshape(10, 3)</span><br><span class="line">idx = [&quot;ax&quot;, &quot;bx&quot;, &quot;cx&quot;]</span><br><span class="line">df = pd.DataFrame(val, columns = idx,index=list(&quot;abcdefghij&quot;))</span><br><span class="line"></span><br><span class="line">#[]号访问列</span><br><span class="line">df[&quot;ax&quot;]   #单列索引</span><br><span class="line">df[[&quot;ax&quot;, &quot;cx&quot;]]  #多列手动选择</span><br><span class="line"></span><br><span class="line">#利用列名访问列</span><br><span class="line">df.ax</span><br><span class="line"></span><br><span class="line">#DataFrame[start:end]则是通过切片选择的是行。</span><br><span class="line">df[&quot;a&quot; : &quot;e&quot;]</span><br><span class="line">df[:3]    #多列切片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###利用方法进行选择</span><br><span class="line"></span><br><span class="line">#按位置索引选择：iloc[]行列切片</span><br><span class="line">df.iloc[1] #单独使用选择行</span><br><span class="line">df.iloc[2 : 6, 0 : 2]   #行列选择</span><br><span class="line">df.iloc[[0, 1, 3]]   #不同行选择</span><br><span class="line">df.iloc[[0, 1, 3],[2,1]]   #不同行列选择</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#按标签选择  loc[]行列切片， 行列的名字  dataFrame里可以通过loc[]的方式选择label标识的行数据。</span><br><span class="line">df.loc[&quot;a&quot;] #单独使用选择行</span><br><span class="line">df.loc[[&quot;a&quot;,&quot;c&quot;]]</span><br><span class="line">df.loc[[&quot;a&quot;,&quot;c&quot;],[&quot;ax&quot;,&quot;cx&quot;]]</span><br><span class="line">df.loc[&quot;b&quot; : &quot;e&quot;, &quot;bx&quot; : &quot;cx&quot;]</span><br><span class="line">df.loc[: , &quot;bx&quot; : &quot;cx&quot;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="bool逻辑筛选数据"><a href="#bool逻辑筛选数据" class="headerlink" title="bool逻辑筛选数据"></a>bool逻辑筛选数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">val = np.arange(10, 60).reshape(10, 5)</span><br><span class="line">col = [&quot;ax&quot;, &quot;bx&quot;, &quot;cx&quot;, &quot;dx&quot;, &quot;ex&quot;]</span><br><span class="line">idx = list(&quot;abcdefghij&quot;)</span><br><span class="line">df = pd.DataFrame(val, columns = col, index = idx)</span><br><span class="line"></span><br><span class="line">#筛选，bx列大于30的数据</span><br><span class="line">bs = df[&quot;bx&quot;] &gt; 30</span><br><span class="line">df[bs]</span><br><span class="line"></span><br><span class="line">#组合选择，bx列大于30的数据并且cx列大于40的数据</span><br><span class="line"></span><br><span class="line">bs = (df[&quot;bx&quot;] &gt; 30) &amp; (df[&quot;cx&quot;] &gt; 40)</span><br><span class="line">df[bs]     #选择符合条件的行</span><br><span class="line"></span><br><span class="line">#布尔选择的结果还是DataFrame，所以对于结果可以进行切片、label、loc等访问。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="dataframe数据分类统计（重要）"><a href="#dataframe数据分类统计（重要）" class="headerlink" title="dataframe数据分类统计（重要）"></a>dataframe数据分类统计（重要）</h5><p>apply 方法  和  groupby方法对数据进行分类统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">val = np.arange(10, 60).reshape(10, 5)</span><br><span class="line">col = [&quot;ax&quot;, &quot;bx&quot;, &quot;cx&quot;, &quot;dx&quot;, &quot;ex&quot;]</span><br><span class="line">idx = list(&quot;abcdefghij&quot;)</span><br><span class="line">df = pd.DataFrame(val, columns = col, index = idx)</span><br><span class="line"></span><br><span class="line">df.apply(lambda col : col.sum(), axis = 0)  #求列的和</span><br><span class="line">df.apply(lambda row : row.sum(), axis = 1)  #求行的和</span><br><span class="line">df[&quot;plus&quot;] = df.apply(lambda row : row.ax + row.cx, axis = 1) #两列相加，并增加新列，plus</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p>groupby 方法，实现分类汇总</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">idx = [101,101,101,102,102,102,103,103,103]</span><br><span class="line">name = [&quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;, &quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;]</span><br><span class="line">price = [1.0,2.0,3.0,4.00,5.0,6.0,7.0,8.0,9.0]</span><br><span class="line">df0 = pd.DataFrame(&#123; &quot;fruit&quot;: name, &quot;price&quot; : price, &quot;supplier&quot; :idx&#125;)</span><br><span class="line"></span><br><span class="line">dg =  df0.groupby(&quot;fruit&quot;)</span><br><span class="line"></span><br><span class="line">#批量查看分组结果</span><br><span class="line">for n, g in dg:</span><br><span class="line">    print(&quot;group_name:&quot;, n, &quot;\n&quot;,g,)</span><br><span class="line"></span><br><span class="line">#分析结果总结</span><br><span class="line">dg.describe()</span><br><span class="line"></span><br><span class="line">#选择需要研究的列,属性或者方法获得统计结果</span><br><span class="line">dg[&#x27;price&#x27;].mean() </span><br><span class="line">dg[&#x27;supplier&#x27;].value_counts()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#多个分组，大分组之后再分亚组</span><br><span class="line">import pandas as pd</span><br><span class="line">idx = [101,101,101,102,102,102,103,103,103,101,101,101,102,102,102,103,103,103]</span><br><span class="line">name = [&quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;, &quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;, &quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;pearl&quot;,&quot;orange&quot;]</span><br><span class="line">price = np.arange(18)</span><br><span class="line">df0 = pd.DataFrame(&#123; &quot;fruit&quot;: name, &quot;price&quot; : price, &quot;supplier&quot; :idx&#125;)</span><br><span class="line"></span><br><span class="line">dg2 =  df0.groupby([&quot;fruit&quot;, &quot;supplier&quot;])</span><br><span class="line">for n, g in dg2:</span><br><span class="line">    print(&quot;multiGroup on:&quot;, n, &quot;\n&quot;,g)</span><br><span class="line">dg2.describe()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;groupby方法总结&#x3D;&#x3D;</p>
<blockquote>
<p>首先通过groupby得到DataFrameGroupBy对象, 然后选择需要研究的列,这样我们就得到了一个SeriesGroupby, 它代表每一个组都有一个Series<br>对SeriesGroupby进行操作, 比如.mean(), 相当于对每个组的Series求均值</p>
</blockquote>
<h4 id="6-3-4-pandas-应用：读入写出数据处理数据"><a href="#6-3-4-pandas-应用：读入写出数据处理数据" class="headerlink" title="6.3.4 pandas 应用：读入写出数据处理数据"></a>6.3.4 pandas 应用：读入写出数据处理数据</h4><p>测试数据：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/iris/">https://archive.ics.uci.edu/ml/machine-learning-databases/iris/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import pandas as pd</span><br><span class="line">os.chdir(&quot;D://python_script//&quot;)</span><br><span class="line">fn = &quot;D://python_script//iris.data&quot;</span><br><span class="line">cols_name = [&#x27;sepal_length&#x27;, &#x27;sepal_width&#x27;, &#x27;petal_length&#x27;, &#x27;petal_width&#x27;, &#x27;class&#x27;]</span><br><span class="line">df = pd.read_csv(fn, names = cols_name)  #更多读取数据：https://pandas.pydata.org/pandas-docs/stable/reference/io.html</span><br><span class="line"></span><br><span class="line">data_df=df.iloc[:,0:4]   #筛选一下数据</span><br><span class="line"></span><br><span class="line">#利用apply计算：行列的和</span><br><span class="line"></span><br><span class="line">data_df.apply(lambda col : col.sum(), axis = 0)</span><br><span class="line">data_df.apply(lambda row : row.sum(), axis = 1)</span><br><span class="line"></span><br><span class="line">#自定义计算</span><br><span class="line">data_df[&quot;sepal_length x sepal_width&quot;] =data_df.apply(lambda row : row.sepal_width * row.sepal_length, axis = 1)</span><br><span class="line">data_df</span><br><span class="line"></span><br><span class="line">data_df.to_csv(&quot;out.csv&quot;)  #计算结果写出</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Learn_Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 绘图matplotlib包科学绘图</title>
    <url>/2024/07/02/Python%E7%BB%98%E5%9B%BEmatplotlib/</url>
    <content><![CDATA[<h1 id="Python-绘图matplotlib包科学绘图"><a href="#Python-绘图matplotlib包科学绘图" class="headerlink" title="Python 绘图matplotlib包科学绘图"></a>Python 绘图matplotlib包科学绘图</h1><p>Matplotlib:</p>
<p>Python中最著名的绘图系统，pandas绘图也是由其封装而成。</p>
<p>官方网站：<a href="https://matplotlib.org/">https://matplotlib.org/</a></p>
<h2 id="1-认识matplotlib绘图包绘图要素以及对应的类（对象）"><a href="#1-认识matplotlib绘图包绘图要素以及对应的类（对象）" class="headerlink" title="1 认识matplotlib绘图包绘图要素以及对应的类（对象）"></a>1 认识matplotlib绘图包绘图要素以及对应的类（对象）</h2><ul>
<li>Figure</li>
</ul>
<p>The whole figure. The figure keeps track of all the child Axes, a smattering of ‘special’ artists (titles, figure legends, etc), and the canvas。</p>
<p> The top level container Artist is the matplotlib.figure.Figure</p>
<ul>
<li>Axes</li>
</ul>
<p>This is what you think of as ‘a plot’, it is the region of the image with the data space. A given figure can contain many Axes, but a given Axes object can only be in one Figure. </p>
<ul>
<li>Axis</li>
</ul>
<p>These are the number-line-like objects.  They take care of setting the graph limits and generating the ticks (the marks on the axis) and ticklabels (strings labeling the ticks).</p>
<ul>
<li>Artist</li>
</ul>
<p>Basically everything you can see on the figure is an artist (even the Figure, Axes, and Axis objects). This includes Text objects, Line2D objects, collection objects, Patch objects … (you get the idea).</p>
<h4 id="要素之间的关系："><a href="#要素之间的关系：" class="headerlink" title="要素之间的关系："></a>要素之间的关系：</h4><p><img src="https://note.youdao.com/yws/api/group/92990402/noteresource/2D9C4B8F4FD742F6A8A1B8B423A18DF4/version/1811?method=get-resource&shareToken=08DB9C16FB6D47AA8EBD104017423D2D&entryId=446741437" alt="image"></p>
<h4 id="多张图，要素之间的关系："><a href="#多张图，要素之间的关系：" class="headerlink" title="多张图，要素之间的关系："></a>多张图，要素之间的关系：</h4><p><img src="https://note.youdao.com/yws/api/group/92990402/noteresource/42A13F509ADF4308BE2D8552668570E6/version/1798?method=get-resource&shareToken=08DB9C16FB6D47AA8EBD104017423D2D&entryId=446741437" alt="image"></p>
<h3 id="Figure中更详细对象总结"><a href="#Figure中更详细对象总结" class="headerlink" title="Figure中更详细对象总结"></a>Figure中更详细对象总结</h3><p><img src="https://note.youdao.com/yws/api/group/92990402/noteresource/7860471E3BDB4C8598952F1739C415B7/version/1783?method=get-resource&shareToken=08DB9C16FB6D47AA8EBD104017423D2D&entryId=446741437" alt="image"></p>
<h2 id="2-matplotlib包安装"><a href="#2-matplotlib包安装" class="headerlink" title="2 matplotlib包安装"></a>2 matplotlib包安装</h2><p>安装说明：<br><a href="https://matplotlib.org/users/installing.html#installing-an-official-release">https://matplotlib.org/users/installing.html#installing-an-official-release</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">#jupyter 支持绘图显示，命令行需要安装运行以下代码：</span><br><span class="line"></span><br><span class="line">pip install ipympl  -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">jupyter nbextension enable --py --sys-prefix ipympl</span><br></pre></td></tr></table></figure>



<h2 id="3-matplotlib绘图基础"><a href="#3-matplotlib绘图基础" class="headerlink" title="3 matplotlib绘图基础"></a>3 matplotlib绘图基础</h2><h3 id="matplotlib-pyplot-绘图入口模块"><a href="#matplotlib-pyplot-绘图入口模块" class="headerlink" title="matplotlib.pyplot 绘图入口模块"></a>matplotlib.pyplot 绘图入口模块</h3><p>&#x3D;&#x3D;matplotlib.pyplot 模块中有很多函数，我们直接调用就可以绘图：&#x3D;&#x3D;</p>
<p>Everything in matplotlib is organized in a hierarchy. At the top of the hierarchy is the matplotlib “state-machine environment” which is provided by the <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot">matplotlib.pyplot</a> module.</p>
<p>我们使用matplotlib.pyplot 里面的函数来创建绘图，绘图主要有以下三步：</p>
<ul>
<li>第一步：创建Figure对象，相当于画布</li>
<li>第二步：画布中添加Axes对象，画布中可以有很多图（Axes）</li>
<li>第三步：利用Axes对象的方法绘图（plot，bar，pie等等）</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#########################################</span><br><span class="line">#载入包，模块等等</span><br><span class="line">#########################################</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">###########################</span><br><span class="line">##第一步和第二步：  获得，Figure对象和Axes对象</span><br><span class="line">###########################</span><br><span class="line"></span><br><span class="line">#方法1：</span><br><span class="line">fig = plt.figure(figsize=(8, 6))</span><br><span class="line">ax1 = fig.add_axes([0.1, 0.1, 0.35, 0.8])</span><br><span class="line">ax2 = fig.add_axes([0.55, 0.1, 0.35, 0.8])</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">ax1 = fig.add_subplot(211)</span><br><span class="line">ax2 = fig.add_subplot(212)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#方法2：</span><br><span class="line">fig, ax = plt.subplots(figsize=(8, 6))</span><br><span class="line">#或者 </span><br><span class="line">fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2,figsize=(8, 6))</span><br><span class="line"></span><br><span class="line">##########################</span><br><span class="line">##第三步： 绘图</span><br><span class="line">#############################</span><br><span class="line"></span><br><span class="line">x = np.linspace(0, 2, 100)   </span><br><span class="line">fig, ax = plt.subplots(figsize=(8, 6))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.plot(x, x, label=&#x27;linear&#x27;)</span><br><span class="line">ax.plot(x, x**2, label=&#x27;quadratic&#x27;)</span><br><span class="line">ax.plot(x, x**3, label=&#x27;cubic&#x27;)</span><br><span class="line">ax.set_xlabel(&#x27;x label&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;y label&#x27;)</span><br><span class="line">ax.set_title(&quot;Simple Plot&quot;)</span><br><span class="line">ax.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">#保存图片</span><br><span class="line">#plt.savefig(&quot;D:\\python_script\\test.pdf&quot;)</span><br><span class="line">#plt.savefig(&quot;D:\\python_script\\test.png&quot;,dpi=300)</span><br></pre></td></tr></table></figure>


<h3 id="面向对象绘图和面向过程的绘图"><a href="#面向对象绘图和面向过程的绘图" class="headerlink" title="面向对象绘图和面向过程的绘图"></a>面向对象绘图和面向过程的绘图</h3><p>推荐面向对象的绘图，思路会更加清晰。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(0, 2, 100)</span><br><span class="line">plt.plot(x, x, label=&#x27;linear&#x27;)</span><br><span class="line">plt.plot(x, x**2, label=&#x27;quadratic&#x27;)</span><br><span class="line">plt.plot(x, x**3, label=&#x27;cubic&#x27;)</span><br><span class="line">plt.xlabel(&#x27;x label&#x27;)</span><br><span class="line">plt.ylabel(&#x27;y label&#x27;)</span><br><span class="line">plt.title(&quot;Simple Plot&quot;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-学会自学绘图"><a href="#3-学会自学绘图" class="headerlink" title="3 学会自学绘图"></a>3 学会自学绘图</h2><h3 id="方法模板的API：每个类、方法、函数，参数的详细说明"><a href="#方法模板的API：每个类、方法、函数，参数的详细说明" class="headerlink" title="方法模板的API：每个类、方法、函数，参数的详细说明"></a>方法模板的API：每个类、方法、函数，参数的详细说明</h3><p><a href="https://matplotlib.org/api/index.html#modules">https://matplotlib.org/api/index.html#modules</a></p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p><a href="https://matplotlib.org/users/index.html">https://matplotlib.org/users/index.html</a></p>
<h3 id="利用例子学习绘图"><a href="#利用例子学习绘图" class="headerlink" title="利用例子学习绘图"></a>利用例子学习绘图</h3><p><a href="https://matplotlib.org/gallery/index.html">https://matplotlib.org/gallery/index.html</a></p>
]]></content>
      <categories>
        <category>Learn_Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
